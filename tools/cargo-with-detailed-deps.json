{
  "type": "object",
  "$comment": "Derived from https://www.schemastore.org/cargo.json, with edits to force default-features=false",
  "$id": "https://json.schemastore.org/cargo.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "additionalProperties": false,
  "definitions": {
    "Authors": {
      "type": "array",
      "description": "The `authors` field lists people or organizations that are considered the\n\"authors\" of the package. The exact meaning is open to interpretation \u2014 it may\nlist the original or primary authors, current maintainers, or owners of the\npackage. These names will be listed on the crate's page on\n[crates.io](https://crates.io). An optional email address may be included within angled\nbrackets at the end of each author.\n\n> **Note**: [crates.io](https://crates.io) requires at least one author to be listed.",
      "items": {
        "type": "string",
        "description": "The `authors` field lists people or organizations that are considered the\n\"authors\" of the package. The exact meaning is open to interpretation \u2014 it may\nlist the original or primary authors, current maintainers, or owners of the\npackage. These names will be listed on the crate's page on\n[crates.io](https://crates.io). An optional email address may be included within angled\nbrackets at the end of each author.\n\n> **Note**: [crates.io](https://crates.io) requires at least one author to be listed.",
        "x-taplo": {
          "links": {
            "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-authors-field"
          }
        }
      },
      "title": "Authors",
      "uniqueItems": true,
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-authors-field"
        }
      },
      "x-tombi-array-values-order": "version-sort"
    },
    "Build": {
      "anyOf": [
        {
          "type": "string",
          "description": "Path to the build file."
        },
        {
          "type": "boolean",
          "enum": [
            true,
            false
          ],
          "x-taplo": {
            "docs": {
              "enumValues": [
                "Automatically detect the build file (`build.rs`).",
                "Disable automatic detection of the build file."
              ]
            }
          }
        }
      ],
      "description": "The `build` field specifies a file in the package root which is a [build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) for building native code. More information can be found in the [build script guide](https://doc.rust-lang.org/cargo/reference/build-scripts.html).\n\n\n```toml\n[package]\n# ...\nbuild = \"build.rs\"\n```\n\nThe default is `\"build.rs\"`, which loads the script from a file named\n`build.rs` in the root of the package. Use `build = \"custom_build_name.rs\"` to\nspecify a path to a different file or `build = false` to disable automatic\ndetection of the build script.\n",
      "title": "Build",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-build-field"
        }
      }
    },
    "BuildOverride": {
      "allOf": [
        {
          "$ref": "#/definitions/Profile"
        }
      ],
      "description": "Profile settings can be overridden for specific packages and build-time\ncrates. To override the settings for a specific package, use the `package`\ntable to change the settings for the named package:\n\n```toml\n# The `foo` package will use the -Copt-level=3 flag.\n[profile.dev.package.foo]\nopt-level = 3\n```\n\nThe package name is actually a [Package ID Spec](https://doc.rust-lang.org/cargo/reference/pkgid-spec.html), so you can\ntarget individual versions of a package with syntax such as\n`[profile.dev.package.\"foo:2.1.0\"]`.\n\nTo override the settings for all dependencies (but not any workspace member),\nuse the `\"*\"` package name:\n\n```toml\n# Set the default for dependencies.\n[profile.dev.package.\"*\"]\nopt-level = 2\n```\n\nTo override the settings for build scripts, proc macros, and their\ndependencies, use the `build-override` table:\n\n```toml\n# Set the settings for build scripts and proc-macros.\n[profile.dev.build-override]\nopt-level = 3\n```\n\n> Note: When a dependency is both a normal dependency and a build dependency,\n> Cargo will try to only build it once when `--target` is not specified. When\n> using `build-override`, the dependency may need to be built twice, once as a\n> normal dependency and once with the overridden build settings. This may\n> increase initial build times.\n",
      "title": "Build Override",
      "x-taplo": {
        "docs": {
          "main": "Profile settings can be overridden for specific packages and build-time\ncrates. To override the settings for a specific package, use the `package`\ntable to change the settings for the named package:\n\n```toml\n# The `foo` package will use the -Copt-level=3 flag.\n[profile.dev.package.foo]\nopt-level = 3\n```\n\nThe package name is actually a [Package ID Spec](https://doc.rust-lang.org/cargo/reference/pkgid-spec.html), so you can\ntarget individual versions of a package with syntax such as\n`[profile.dev.package.\"foo:2.1.0\"]`.\n\nTo override the settings for all dependencies (but not any workspace member),\nuse the `\"*\"` package name:\n\n```toml\n# Set the default for dependencies.\n[profile.dev.package.\"*\"]\nopt-level = 2\n```\n\nTo override the settings for build scripts, proc macros, and their\ndependencies, use the `build-override` table:\n\n```toml\n# Set the settings for build scripts and proc-macros.\n[profile.dev.build-override]\nopt-level = 3\n```\n\n> Note: When a dependency is both a normal dependency and a build dependency,\n> Cargo will try to only build it once when `--target` is not specified. When\n> using `build-override`, the dependency may need to be built twice, once as a\n> normal dependency and once with the overridden build settings. This may\n> increase initial build times.\n"
        },
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#overrides"
        }
      }
    },
    "Categories": {
      "type": "array",
      "description": "The `categories` field is an array of strings of the categories this package\nbelongs to.\n\n```toml\ncategories = [\"command-line-utilities\", \"development-tools::cargo-plugins\"]\n```\n\n> **Note**: [crates.io](https://crates.io) has a maximum of 5 categories. Each category should\n> match one of the strings available at https://crates.io/category_slugs, and\n> must match exactly.",
      "items": {
        "type": "string",
        "description": "The `categories` field is an array of strings of the categories this package\nbelongs to.\n\n```toml\ncategories = [\"command-line-utilities\", \"development-tools::cargo-plugins\"]\n```\n\n> **Note**: [crates.io](https://crates.io) has a maximum of 5 categories. Each category should\n> match one of the strings available at https://crates.io/category_slugs, and\n> must match exactly.",
        "x-taplo": {
          "links": {
            "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-categories-field"
          }
        }
      },
      "title": "Categories",
      "uniqueItems": true,
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-categories-field"
        }
      },
      "x-tombi-array-values-order": "version-sort"
    },
    "CodegenUnits": {
      "type": "integer",
      "description": "The `codegen-units` setting controls the [`-C codegen-units` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#codegen-units) which\ncontrols how many \"code generation units\" a crate will be split into. More\ncode generation units allows more of a crate to be processed in parallel\npossibly reducing compile time, but may produce slower code.\n\nThis option takes an integer greater than 0.\n\nThe default is 256 for [incremental](https://doc.rust-lang.org/cargo/reference/profiles.html#incremental) builds, and 16 for\nnon-incremental builds.",
      "format": "uint32",
      "minimum": 0,
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#codegen-units"
        }
      }
    },
    "DebugAssertions": {
      "type": "boolean",
      "description": "The `debug-assertions` setting controls the [`-C debug-assertions` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#debug-assertions) which\nturns `cfg(debug_assertions)` [conditional compilation](https://doc.rust-lang.org/reference/conditional-compilation.html#debug_assertions) on or off. Debug\nassertions are intended to include runtime validation which is only available\nin debug/development builds. These may be things that are too expensive or\notherwise undesirable in a release build. Debug assertions enables the\n[`debug_assert!` macro](https://doc.rust-lang.org/std/macro.debug_assert.html) in the standard library.",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#debug-assertions"
        }
      }
    },
    "DebugLevel": {
      "description": "The `debug` setting controls the [`-C debuginfo` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#debuginfo) which controls the\namount of debug information included in the compiled binary.",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "none",
            "line-directives-only",
            "line-tables-only",
            "limited",
            "full"
          ]
        },
        {
          "type": "boolean"
        },
        {
          "type": "integer",
          "enum": [
            0,
            1,
            2
          ]
        }
      ],
      "title": "Debug Level",
      "x-taplo": {
        "docs": {
          "enumValues": [
            "No debug info at all, default for `release` profile",
            "Debug info without type or variable-level information. Generates more detailed module-level info than `line-tables-only`.",
            "Full debug info, default for `dev` profile",
            "Full debug info, default for `dev` profile",
            "No debug info at all, default for `release` profile",
            "No debug info at all, default for `release` profile",
            "Line info directives only. For the nvptx* targets this enables [profiling](https://reviews.llvm.org/D46061). For other use cases, `line-tables-only` is the better, more compatible choice.",
            "Line tables only. Generates the minimal amount of debug info for backtraces with filename/line number info, but not anything else, i.e. no variable or function parameter info.",
            "Debug info without type or variable-level information. Generates more detailed module-level info than `line-tables-only`.",
            "Full debug info, default for `dev` profile"
          ]
        },
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#debug"
        }
      }
    },
    "Dependency": {
      "$ref": "#/definitions/DetailedDependency",
      "title": "Dependency"
    },
    "Description": {
      "type": "string",
      "description": "The description is a short blurb about the package. [crates.io](https://crates.io) will display\nthis with your package. This should be plain text (not Markdown).\n\n```toml\n[package]\n# ...\ndescription = \"A short description of my package\"\n```\n\n> **Note**: [crates.io](https://crates.io) requires the `description` to be set.",
      "title": "Description",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-description-field"
        }
      }
    },
    "DetailedDependency": {
      "type": "object",
      "additionalProperties": false,
      "dependencies": {
        "version": [
          "default-features"
        ]
      },
      "minProperties": 1,
      "properties": {
        "branch": {
          "type": "string",
          "description": "Specify the Git branch to use in case of a [Git dependency](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories).",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories"
            }
          }
        },
        "default-features": {
          "type": "boolean",
          "description": "Use the default features of the dependency.",
          "enum": [
            false
          ],
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#choosing-features"
            }
          }
        },
        "default_features": {
          "type": "boolean",
          "deprecated": true,
          "description": "\"default_features\" is deprecated. Use \"default-features\" instead.",
          "x-taplo": {
            "hidden": true
          }
        },
        "features": {
          "type": "array",
          "description": "List of features to activate in the dependency.",
          "items": {
            "type": "string",
            "description": "List of features to activate in the dependency.",
            "x-taplo": {
              "crates": {
                "schemas": "feature"
              },
              "links": {
                "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#choosing-features"
              },
              "plugins": [
                "crates"
              ]
            }
          },
          "uniqueItems": true,
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#choosing-features"
            }
          },
          "x-tombi-array-values-order": "version-sort"
        },
        "git": {
          "type": "string",
          "description": "To depend on a library located in a `git` repository, the minimum information\nyou need to specify is the location of the repository with the `git` key:\n\n```toml\n[dependencies]\nrand = { git = \"https://github.com/rust-lang-nursery/rand\" }\n```\n\nCargo will fetch the `git` repository at this location then look for a\n`Cargo.toml` for the requested crate anywhere inside the `git` repository\n(not necessarily at the root - for example, specifying a member crate name\nof a workspace and setting `git` to the repository containing the workspace).\n\nSince we haven't specified any other information, Cargo assumes that\nwe intend to use the latest commit on the main branch to build our package.\nYou can combine the `git` key with the `rev`, `tag`, or `branch` keys to\nspecify something else. Here's an example of specifying that you want to use\nthe latest commit on a branch named `next`:\n\n```toml\n[dependencies]\nrand = { git = \"https://github.com/rust-lang-nursery/rand\", branch = \"next\" }\n```\n\nSee [Git Authentication](https://doc.rust-lang.org/cargo/appendix/git-authentication.html) for help with git authentication for private repos.\n\n> **Note**: [crates.io](https://crates.io/) does not allow packages to be published with `git`\n> dependencies (`git` [dev-dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies) are ignored). See the [Multiple\n> locations](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#multiple-locations) section for a fallback alternative.\n",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories"
            }
          }
        },
        "optional": {
          "type": "boolean",
          "description": "Mark the dependency as optional.\n\nOptional dependencies can be activated through features.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#choosing-features"
            }
          }
        },
        "package": {
          "type": "string",
          "description": "Specify the name of the package.\n\nWhen writing a `[dependencies]` section in `Cargo.toml` the key you write for a\ndependency typically matches up to the name of the crate you import from in the\ncode. For some projects, though, you may wish to reference the crate with a\ndifferent name in the code regardless of how it's published on crates.io. For\nexample you may wish to:\n\n* Avoid the need to  `use foo as bar` in Rust source.\n* Depend on multiple versions of a crate.\n* Depend on crates with the same name from different registries.\n\nTo support this Cargo supports a `package` key in the `[dependencies]` section\nof which package should be depended on:\n\n```toml\n[package]\nname = \"mypackage\"\nversion = \"0.0.1\"\n\n[dependencies]\nfoo = \"0.1\"\nbar = { git = \"https://github.com/example/project\", package = \"foo\" }\nbaz = { version = \"0.1\", registry = \"custom\", package = \"foo\" }\n```\n\nIn this example, three crates are now available in your Rust code:\n\n```rust\nextern crate foo; // crates.io\nextern crate bar; // git repository\nextern crate baz; // registry `custom`\n```\n\nAll three of these crates have the package name of `foo` in their own\n`Cargo.toml`, so we're explicitly using the `package` key to inform Cargo that\nwe want the `foo` package even though we're calling it something else locally.\nThe `package` key, if not specified, defaults to the name of the dependency\nbeing requested.\n",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml"
            }
          }
        },
        "path": {
          "type": "string",
          "description": "Cargo supports **path dependencies** which are typically sub-crates that live within one repository.\nLet's start off by making a new crate inside of our `hello_world` package:\n\n```console\n# inside of hello_world/\n$ cargo new hello_utils\n```\n\nThis will create a new folder `hello_utils` inside of which a `Cargo.toml` and\n`src` folder are ready to be configured. In order to tell Cargo about this, open\nup `hello_world/Cargo.toml` and add `hello_utils` to your dependencies:\n\n```toml\n[dependencies]\nhello_utils = { path = \"hello_utils\" }\n```\n\nThis tells Cargo that we depend on a crate called `hello_utils` which is found\nin the `hello_utils` folder (relative to the `Cargo.toml` it's written in).",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies"
            }
          }
        },
        "public": {
          "type": "boolean",
          "x-taplo": {
            "hidden": true
          }
        },
        "registry": {
          "type": "string",
          "description": "To specify a dependency from a registry other than [crates.io](https://crates.io), first the\nregistry must be configured in a `.cargo/config.toml` file. See the [registries\ndocumentation](https://doc.rust-lang.org/cargo/reference/registries.html) for more information. In the dependency, set the `registry` key\nto the name of the registry to use.\n\n```toml\n[dependencies]\nsome-crate = { version = \"1.0\", registry = \"my-registry\" }\n```\n\n> **Note**: [crates.io](https://crates.io) does not allow packages to be published with\n> dependencies on other registries.\n",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-other-registries"
            }
          }
        },
        "registry-index": {
          "type": "string",
          "x-taplo": {
            "hidden": true
          }
        },
        "rev": {
          "type": "string",
          "description": "Specify the Git revision to use in case of a [Git dependency](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#choice-of-commit).\n\nThis can be a commit hash, or a named reference exposed by the remote repository. GitHub Pull Requests may be specified using the `refs/pull/ID/head` format.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#choice-of-commit"
            }
          }
        },
        "tag": {
          "type": "string",
          "description": "Specify the Git tag to use in case of a [Git dependency](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories).",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories"
            }
          }
        },
        "version": {
          "$ref": "#/definitions/SemVerRequirement"
        },
        "workspace": {
          "type": "boolean",
          "description": "Inherit this dependency from the workspace manifest.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace"
            }
          }
        }
      },
      "title": "Detailed Dependency",
      "x-taplo": {
        "initFields": [
          "version"
        ]
      },
      "x-tombi-table-keys-order": "schema"
    },
    "DetailedLint": {
      "type": "object",
      "properties": {
        "level": {
          "$ref": "#/definitions/LintLevel"
        },
        "priority": {
          "type": "integer",
          "description": "The priority that controls which lints or [lint groups](https://doc.rust-lang.org/rustc/lints/groups.html) override other lint groups. Lower (particularly negative) numbers have lower priority, being overridden by higher numbers, and show up first on the command-line to tools like rustc.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/stable/cargo/reference/manifest.html#the-lints-section"
            }
          }
        }
      },
      "title": "Detailed Lint",
      "x-tombi-table-keys-order": "version-sort"
    },
    "Documentation": {
      "type": "string",
      "description": "\nThe `documentation` field specifies a URL to a website hosting the crate's\ndocumentation. If no URL is specified in the manifest file, [crates.io](https://crates.io) will\nautomatically link your crate to the corresponding [docs.rs](https://docs.rs) page.\n\n```toml\n[package]\n# ...\ndocumentation = \"https://docs.rs/bitflags\"\n```\n",
      "title": "Documentation",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-documentation-field"
        }
      }
    },
    "Edition": {
      "type": "string",
      "description": "The `edition` key affects which edition your package is compiled with. Cargo\nwill always generate packages via [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the `edition` key set to the\nlatest edition. Setting the `edition` key in `[package]` will affect all\ntargets/crates in the package, including test suites, benchmarks, binaries,\nexamples, etc.",
      "enum": [
        "2015",
        "2018",
        "2021",
        "2024"
      ],
      "title": "Edition",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/stable/edition-guide/introduction.html"
        }
      }
    },
    "Exclude": {
      "type": "array",
      "description": "You can explicitly specify that a set of file patterns should be ignored or\nincluded for the purposes of packaging. The patterns specified in the\n`exclude` field identify a set of files that are not included, and the\npatterns in `include` specify files that are explicitly included.\n\nThe patterns should be [gitignore](https://git-scm.com/docs/gitignore)-style patterns. Briefly:\n\n- `foo` matches any file or directory with the name `foo` anywhere in the\n  package. This is equivalent to the pattern `**/foo`.\n- `/foo` matches any file or directory with the name `foo` only in the root of\n  the package.\n- `foo/` matches any *directory* with the name `foo` anywhere in the package.\n- Common glob patterns like `*`, `?`, and `[]` are supported:\n  - `*` matches zero or more characters except `/`.  For example, `*.html`\n    matches any file or directory with the `.html` extension anywhere in the\n    package.\n  - `?` matches any character except `/`. For example, `foo?` matches `food`,\n    but not `foo`.\n  - `[]` allows for matching a range of characters. For example, `[ab]`\n    matches either `a` or `b`. `[a-z]` matches letters a through z.\n- `**/` prefix matches in any directory. For example, `**/foo/bar` matches the\n  file or directory `bar` anywhere that is directly under directory `foo`.\n- `/**` suffix matches everything inside. For example, `foo/**` matches all\n  files inside directory `foo`, including all files in subdirectories below\n  `foo`.\n- `/**/` matches zero or more directories. For example, `a/**/b` matches\n  `a/b`, `a/x/b`, `a/x/y/b`, and so on.\n- `!` prefix negates a pattern. For example, a pattern of `src/**.rs` and\n  `!foo.rs` would match all files with the `.rs` extension inside the `src`\n  directory, except for any file named `foo.rs`.\n\nIf git is being used for a package, the `exclude` field will be seeded with\nthe `gitignore` settings from the repository.\n\n```toml\n[package]\n# ...\nexclude = [\"build/**/*.o\", \"doc/**/*.html\"]\n```\n\n```toml\n[package]\n# ...\ninclude = [\"src/**/*\", \"Cargo.toml\"]\n```\n\nThe options are mutually exclusive: setting `include` will override an\n`exclude`. Note that `include` must be an exhaustive list of files as otherwise\nnecessary source files may not be included. The package's `Cargo.toml` is\nautomatically included.\n\nThe include/exclude list is also used for change tracking in some situations.\nFor targets built with `rustdoc`, it is used to determine the list of files to\ntrack to determine if the target should be rebuilt. If the package has a\n[build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) that does not emit any `rerun-if-*` directives, then the\ninclude/exclude list is used for tracking if the build script should be re-run\nif any of those files change.",
      "items": {
        "type": "string",
        "description": "You can explicitly specify that a set of file patterns should be ignored or\nincluded for the purposes of packaging. The patterns specified in the\n`exclude` field identify a set of files that are not included, and the\npatterns in `include` specify files that are explicitly included.\n\nThe patterns should be [gitignore](https://git-scm.com/docs/gitignore)-style patterns. Briefly:\n\n- `foo` matches any file or directory with the name `foo` anywhere in the\n  package. This is equivalent to the pattern `**/foo`.\n- `/foo` matches any file or directory with the name `foo` only in the root of\n  the package.\n- `foo/` matches any *directory* with the name `foo` anywhere in the package.\n- Common glob patterns like `*`, `?`, and `[]` are supported:\n  - `*` matches zero or more characters except `/`.  For example, `*.html`\n    matches any file or directory with the `.html` extension anywhere in the\n    package.\n  - `?` matches any character except `/`. For example, `foo?` matches `food`,\n    but not `foo`.\n  - `[]` allows for matching a range of characters. For example, `[ab]`\n    matches either `a` or `b`. `[a-z]` matches letters a through z.\n- `**/` prefix matches in any directory. For example, `**/foo/bar` matches the\n  file or directory `bar` anywhere that is directly under directory `foo`.\n- `/**` suffix matches everything inside. For example, `foo/**` matches all\n  files inside directory `foo`, including all files in subdirectories below\n  `foo`.\n- `/**/` matches zero or more directories. For example, `a/**/b` matches\n  `a/b`, `a/x/b`, `a/x/y/b`, and so on.\n- `!` prefix negates a pattern. For example, a pattern of `src/**.rs` and\n  `!foo.rs` would match all files with the `.rs` extension inside the `src`\n  directory, except for any file named `foo.rs`.\n\nIf git is being used for a package, the `exclude` field will be seeded with\nthe `gitignore` settings from the repository.\n\n```toml\n[package]\n# ...\nexclude = [\"build/**/*.o\", \"doc/**/*.html\"]\n```\n\n```toml\n[package]\n# ...\ninclude = [\"src/**/*\", \"Cargo.toml\"]\n```\n\nThe options are mutually exclusive: setting `include` will override an\n`exclude`. Note that `include` must be an exhaustive list of files as otherwise\nnecessary source files may not be included. The package's `Cargo.toml` is\nautomatically included.\n\nThe include/exclude list is also used for change tracking in some situations.\nFor targets built with `rustdoc`, it is used to determine the list of files to\ntrack to determine if the target should be rebuilt. If the package has a\n[build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) that does not emit any `rerun-if-*` directives, then the\ninclude/exclude list is used for tracking if the build script should be re-run\nif any of those files change.",
        "x-taplo": {
          "links": {
            "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-exclude-and-include-fields"
          }
        }
      },
      "title": "Exclude",
      "uniqueItems": true,
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-exclude-and-include-fields"
        }
      },
      "x-tombi-array-values-order": "version-sort"
    },
    "Homepage": {
      "type": "string",
      "description": "The `homepage` field should be a URL to a site that is the home page for your\npackage.\n\n```toml\n[package]\n# ...\nhomepage = \"https://serde.rs/\"\n```",
      "title": "Homepage",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-homepage-field"
        }
      }
    },
    "Include": {
      "type": "array",
      "description": "You can explicitly specify that a set of file patterns should be ignored or\nincluded for the purposes of packaging. The patterns specified in the\n`exclude` field identify a set of files that are not included, and the\npatterns in `include` specify files that are explicitly included.\n\nThe patterns should be [gitignore](https://git-scm.com/docs/gitignore)-style patterns. Briefly:\n\n- `foo` matches any file or directory with the name `foo` anywhere in the\n  package. This is equivalent to the pattern `**/foo`.\n- `/foo` matches any file or directory with the name `foo` only in the root of\n  the package.\n- `foo/` matches any *directory* with the name `foo` anywhere in the package.\n- Common glob patterns like `*`, `?`, and `[]` are supported:\n  - `*` matches zero or more characters except `/`.  For example, `*.html`\n    matches any file or directory with the `.html` extension anywhere in the\n    package.\n  - `?` matches any character except `/`. For example, `foo?` matches `food`,\n    but not `foo`.\n  - `[]` allows for matching a range of characters. For example, `[ab]`\n    matches either `a` or `b`. `[a-z]` matches letters a through z.\n- `**/` prefix matches in any directory. For example, `**/foo/bar` matches the\n  file or directory `bar` anywhere that is directly under directory `foo`.\n- `/**` suffix matches everything inside. For example, `foo/**` matches all\n  files inside directory `foo`, including all files in subdirectories below\n  `foo`.\n- `/**/` matches zero or more directories. For example, `a/**/b` matches\n  `a/b`, `a/x/b`, `a/x/y/b`, and so on.\n- `!` prefix negates a pattern. For example, a pattern of `src/**.rs` and\n  `!foo.rs` would match all files with the `.rs` extension inside the `src`\n  directory, except for any file named `foo.rs`.\n\nIf git is being used for a package, the `exclude` field will be seeded with\nthe `gitignore` settings from the repository.\n\n```toml\n[package]\n# ...\nexclude = [\"build/**/*.o\", \"doc/**/*.html\"]\n```\n\n```toml\n[package]\n# ...\ninclude = [\"src/**/*\", \"Cargo.toml\"]\n```\n\nThe options are mutually exclusive: setting `include` will override an\n`exclude`. Note that `include` must be an exhaustive list of files as otherwise\nnecessary source files may not be included. The package's `Cargo.toml` is\nautomatically included.\n\nThe include/exclude list is also used for change tracking in some situations.\nFor targets built with `rustdoc`, it is used to determine the list of files to\ntrack to determine if the target should be rebuilt. If the package has a\n[build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) that does not emit any `rerun-if-*` directives, then the\ninclude/exclude list is used for tracking if the build script should be re-run\nif any of those files change.",
      "items": {
        "type": "string",
        "description": "You can explicitly specify that a set of file patterns should be ignored or\nincluded for the purposes of packaging. The patterns specified in the\n`exclude` field identify a set of files that are not included, and the\npatterns in `include` specify files that are explicitly included.\n\nThe patterns should be [gitignore](https://git-scm.com/docs/gitignore)-style patterns. Briefly:\n\n- `foo` matches any file or directory with the name `foo` anywhere in the\n  package. This is equivalent to the pattern `**/foo`.\n- `/foo` matches any file or directory with the name `foo` only in the root of\n  the package.\n- `foo/` matches any *directory* with the name `foo` anywhere in the package.\n- Common glob patterns like `*`, `?`, and `[]` are supported:\n  - `*` matches zero or more characters except `/`.  For example, `*.html`\n    matches any file or directory with the `.html` extension anywhere in the\n    package.\n  - `?` matches any character except `/`. For example, `foo?` matches `food`,\n    but not `foo`.\n  - `[]` allows for matching a range of characters. For example, `[ab]`\n    matches either `a` or `b`. `[a-z]` matches letters a through z.\n- `**/` prefix matches in any directory. For example, `**/foo/bar` matches the\n  file or directory `bar` anywhere that is directly under directory `foo`.\n- `/**` suffix matches everything inside. For example, `foo/**` matches all\n  files inside directory `foo`, including all files in subdirectories below\n  `foo`.\n- `/**/` matches zero or more directories. For example, `a/**/b` matches\n  `a/b`, `a/x/b`, `a/x/y/b`, and so on.\n- `!` prefix negates a pattern. For example, a pattern of `src/**.rs` and\n  `!foo.rs` would match all files with the `.rs` extension inside the `src`\n  directory, except for any file named `foo.rs`.\n\nIf git is being used for a package, the `exclude` field will be seeded with\nthe `gitignore` settings from the repository.\n\n```toml\n[package]\n# ...\nexclude = [\"build/**/*.o\", \"doc/**/*.html\"]\n```\n\n```toml\n[package]\n# ...\ninclude = [\"src/**/*\", \"Cargo.toml\"]\n```\n\nThe options are mutually exclusive: setting `include` will override an\n`exclude`. Note that `include` must be an exhaustive list of files as otherwise\nnecessary source files may not be included. The package's `Cargo.toml` is\nautomatically included.\n\nThe include/exclude list is also used for change tracking in some situations.\nFor targets built with `rustdoc`, it is used to determine the list of files to\ntrack to determine if the target should be rebuilt. If the package has a\n[build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) that does not emit any `rerun-if-*` directives, then the\ninclude/exclude list is used for tracking if the build script should be re-run\nif any of those files change.",
        "x-taplo": {
          "links": {
            "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-exclude-and-include-fields"
          }
        }
      },
      "uniqueItems": true,
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-exclude-and-include-fields"
        }
      },
      "x-tombi-array-values-order": "version-sort"
    },
    "Incremental": {
      "type": "boolean",
      "description": "The `incremental` setting controls the [`-C incremental` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#incremental) which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses `rustc` to to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times. The additional\ninformation is stored in the `target` directory.\n\nThe valid options are:\n\n* `true`: enabled\n* `false`: disabled\n\nIncremental compilation is only used for workspace members and \"path\"\ndependencies.\n\nThe incremental value can be overridden globally with the `CARGO_INCREMENTAL`\n[environment variable](https://doc.rust-lang.org/cargo/reference/environment-variables.html) or the [`build.incremental`](https://doc.rust-lang.org/cargo/reference/config.html#buildincremental) config variable.",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#incremental"
        }
      }
    },
    "Inherits": {
      "type": "string",
      "description": "In addition to the built-in profiles, additional custom profiles can be defined.",
      "enum": [
        "dev",
        "test",
        "bench",
        "release"
      ],
      "title": "Inherits",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#custom-profiles"
        }
      }
    },
    "Keywords": {
      "type": "array",
      "description": "The `keywords` field is an array of strings that describe this package. This\ncan help when searching for the package on a registry, and you may choose any\nwords that would help someone find this crate.\n\n```toml\n[package]\n# ...\nkeywords = [\"gamedev\", \"graphics\"]\n```\n\n> **Note**: [crates.io](https://crates.io) has a maximum of 5 keywords. Each keyword must be\n> ASCII text, start with a letter, and only contain letters, numbers, `_` or\n> `-`, and have at most 20 characters.",
      "items": {
        "type": "string",
        "description": "The `keywords` field is an array of strings that describe this package. This\ncan help when searching for the package on a registry, and you may choose any\nwords that would help someone find this crate.\n\n```toml\n[package]\n# ...\nkeywords = [\"gamedev\", \"graphics\"]\n```\n\n> **Note**: [crates.io](https://crates.io) has a maximum of 5 keywords. Each keyword must be\n> ASCII text, start with a letter, and only contain letters, numbers, `_` or\n> `-`, and have at most 20 characters.",
        "x-taplo": {
          "links": {
            "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-keywords-field"
          }
        }
      },
      "title": "Keywords",
      "uniqueItems": true,
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-keywords-field"
        }
      },
      "x-tombi-array-values-order": "version-sort"
    },
    "License": {
      "type": "string",
      "description": "The `license` field contains the name of the software license that the package\nis released under.\n\n[crates.io](https://crates.io/) interprets the `license` field as an [SPDX 2.1 license\nexpression](https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60). The name must be a known license\nfrom the [SPDX license list 3.6](https://github.com/spdx/license-list-data/tree/v3.6). Parentheses are not\ncurrently supported. See the [SPDX site](https://spdx.org/license-list) for more information.\n\nSPDX license expressions support AND and OR operators to combine multiple\nlicenses.\n\n```toml\n[package]\n# ...\nlicense = \"MIT OR Apache-2.0\"\n```\n\nUsing `OR` indicates the user may choose either license. Using `AND` indicates\nthe user must comply with both licenses simultaneously. The `WITH` operator\nindicates a license with a special exception. Some examples:\n\n* `MIT OR Apache-2.0`\n* `LGPL-2.1 AND MIT AND BSD-2-Clause`\n* `GPL-2.0+ WITH Bison-exception-2.2`\n\nIf a package is using a nonstandard license, then the `license-file` field may\nbe specified in lieu of the `license` field.",
      "title": "License",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-license-and-license-file-fields"
        }
      }
    },
    "LicenseFile": {
      "type": "string",
      "description": "The `license-file` field contains the path to a file\ncontaining the text of the license (relative to this `Cargo.toml`).\n\n```toml\n[package]\n# ...\nlicense-file = \"LICENSE.txt\"\n```\n\n> **Note**: [crates.io](https://crates.io) requires either `license` or `license-file` to be set.",
      "title": "LicenseFile",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-license-and-license-file-fields"
        }
      }
    },
    "Lint": {
      "anyOf": [
        {
          "$ref": "#/definitions/LintLevel"
        },
        {
          "$ref": "#/definitions/DetailedLint"
        }
      ],
      "title": "Lint"
    },
    "LintLevel": {
      "type": "string",
      "description": "Specify the [lint level](https://doc.rust-lang.org/rustc/lints/levels.html) for a lint or lint group.",
      "enum": [
        "forbid",
        "deny",
        "warn",
        "allow"
      ],
      "title": "Lint Level",
      "x-taplo": {
        "docs": {
          "enumValues": [
            "`forbid` is the same as `deny` in that a lint at this level will produce an error, but unlike the `deny` level, the `forbid` level can not be overridden to be anything lower than an error. However, lint levels may still be capped with [`--cap-lints`](https://doc.rust-lang.org/rustc/lints/levels.html#capping-lints) so `rustc --cap-lints warn` will make lints set to `forbid` just warn.",
            "The `deny` lint level produces an error if you violate the lint.",
            "The `warn` lint level produces a warning if you violate the lint.",
            "The `allow` lint level ignores violations of the lint."
          ]
        },
        "links": {
          "key": "https://doc.rust-lang.org/rustc/lints/levels.html"
        }
      }
    },
    "Lints": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "clippy": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Lint"
          },
          "description": "Lint settings for [Clippy](https://doc.rust-lang.org/clippy/). See Clippy's [individual lints](https://rust-lang.github.io/rust-clippy/master/index.html) or [lint groups](https://doc.rust-lang.org/clippy/lints.html) documentation.",
          "x-tombi-table-keys-order": "version-sort"
        },
        "rust": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Lint"
          },
          "description": "Lint settings for the Rust compiler. See the Rust compiler's [individual lints](https://doc.rust-lang.org/rustc/lints/listing/index.html) or [lint groups](https://doc.rust-lang.org/rustc/lints/groups.html).",
          "x-tombi-table-keys-order": "version-sort"
        },
        "rustdoc": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Lint"
          },
          "description": "Lint settings for [Rustdoc](https://doc.rust-lang.org/rustdoc/). See Rustdoc's [individual lints](https://doc.rust-lang.org/rustdoc/lints.html) (rustdoc does not have lint groups)",
          "x-tombi-table-keys-order": "version-sort"
        }
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "Lto": {
      "description": "The `lto` setting controls the [`-C lto` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#lto) which controls LLVM's [link time optimizations](https://llvm.org/docs/LinkTimeOptimization.html). LTO can produce better optimized code, using\nwhole-program analysis, at the cost of longer linking time.\n                    \nSee also the [`-C linker-plugin-lto`](https://doc.rust-lang.org/rustc/codegen-options/index.html#linker-plugin-lto) `rustc` flag for cross-language LTO.",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "fat",
            "thin",
            "off"
          ]
        },
        {
          "type": "boolean"
        }
      ],
      "title": "Lto",
      "x-taplo": {
        "docs": {
          "enumValues": [
            "Performs \"fat\" LTO which attempts to perform optimizations across all crates within the dependency graph.",
            "Performs [\"thin\" LTO](http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html). This is similar to \"fat\", but takes\nsubstantially less time to run while still achieving performance gains\nsimilar to \"fat\".",
            "Disables LTO.",
            "Performs \"fat\" LTO which attempts to perform optimizations across all crates within the dependency graph.",
            "Performs \"thin local LTO\" which performs \"thin\" LTO on the local\ncrate only across its [codegen units](https://doc.rust-lang.org/cargo/reference/profiles.html#codegen-units). No LTO is performed\nif codegen units is 1 or [opt-level](https://doc.rust-lang.org/cargo/reference/profiles.html#opt-level) is 0."
          ]
        },
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#lto"
        }
      }
    },
    "MetaBuild": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "title": "Meta Build",
      "uniqueItems": true,
      "x-tombi-array-values-order": "version-sort"
    },
    "OptLevel": {
      "description": "The `opt-level` setting controls the [`-C opt-level` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#opt-level) which controls the level\nof optimization. Higher optimization levels may produce faster runtime code at\nthe expense of longer compiler times. Higher levels may also change and\nrearrange the compiled code which may make it harder to use with a debugger.\n\nIt is recommended to experiment with different levels to find the right\nbalance for your project. There may be surprising results, such as level `3`\nbeing slower than `2`, or the `\"s\"` and `\"z\"` levels not being necessarily\nsmaller. You may also want to reevaluate your settings over time as newer\nversions of `rustc` changes optimization behavior.\n\nSee also [Profile Guided Optimization](https://doc.rust-lang.org/rustc/profile-guided-optimization.html) for more advanced optimization\ntechniques.",
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "s",
            "z"
          ]
        },
        {
          "type": "integer",
          "enum": [
            0,
            1,
            2,
            3
          ]
        }
      ],
      "title": "Optimization Level",
      "x-taplo": {
        "docs": {
          "enumValues": [
            "No optimizations, also turns on [`cfg(debug_assertions)`](https://doc.rust-lang.org/cargo/reference/profiles.html#debug-assertions).",
            "Basic optimizations.",
            "Some optimizations.",
            "All optimizations.",
            "Optimize for binary size.",
            "Optimize for binary size, but also turn off loop vectorization."
          ]
        },
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#opt-level"
        }
      }
    },
    "OverflowChecks": {
      "type": "boolean",
      "description": "The `overflow-checks` setting controls the [`-C overflow-checks` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#overflow-checks) which\ncontrols the behavior of [runtime integer overflow](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow). When overflow-checks are\nenabled, a panic will occur on overflow.",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#overflow-checks"
        }
      }
    },
    "Package": {
      "type": "object",
      "additionalProperties": false,
      "description": "The only field required by Cargo is [`name`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-name-field).\n If publishing to a registry, the registry may\nrequire additional fields. See the notes below and [the publishing chapter](https://doc.rust-lang.org/cargo/reference/publishing.html) for requirements for publishing to [crates.io](https://crates.io/).",
      "properties": {
        "name": {
          "type": "string",
          "description": "The package name is an identifier used to refer to the package. It is used\nwhen listed as a dependency in another package, and as the default name of\ninferred lib and bin targets.\n\nThe name must use only [alphanumeric](https://doc.rust-lang.org/std/primitive.char.html#method.is_alphanumeric) characters or `-` or `_`, and cannot be empty.\nNote that [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) and [`cargo init`](https://doc.rust-lang.org/cargo/commands/cargo-init.html) impose some additional restrictions on\nthe package name, such as enforcing that it is a valid Rust identifier and not\na keyword. [crates.io](https://crates.io) imposes even more restrictions, such as\nenforcing only ASCII characters, not a reserved name, not a special Windows\nname such as \"nul\", is not too long, etc.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-name-field"
            }
          }
        },
        "authors": {
          "anyOf": [
            {
              "$ref": "#/definitions/Authors"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `authors` field lists people or organizations that are considered the\n\"authors\" of the package. The exact meaning is open to interpretation \u2014 it may\nlist the original or primary authors, current maintainers, or owners of the\npackage. These names will be listed on the crate's page on\n[crates.io](https://crates.io). An optional email address may be included within angled\nbrackets at the end of each author.\n\n> **Note**: [crates.io](https://crates.io) requires at least one author to be listed.",
          "title": "Authors"
        },
        "autobenches": {
          "type": "boolean",
          "description": "Disable automatic discovery of `bench` targets.\n\nDisabling automatic discovery should only be needed for specialized\nsituations. For example, if you have a library where you want a *module* named\n`bin`, this would present a problem because Cargo would usually attempt to\ncompile anything in the `bin` directory as an executable. Here is a sample\nlayout of this scenario:\n\n```\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 bin\n        \u2514\u2500\u2500 mod.rs\n```\n",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery"
            }
          }
        },
        "autobins": {
          "type": "boolean",
          "description": "Disable automatic discovery of `bin` targets.\n\nDisabling automatic discovery should only be needed for specialized\nsituations. For example, if you have a library where you want a *module* named\n`bin`, this would present a problem because Cargo would usually attempt to\ncompile anything in the `bin` directory as an executable. Here is a sample\nlayout of this scenario:\n\n```\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 bin\n        \u2514\u2500\u2500 mod.rs\n```\n\nTo prevent Cargo from inferring `src/bin/mod.rs` as an executable, set\nthis to `false` to disable auto-discovery.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery"
            }
          }
        },
        "autoexamples": {
          "type": "boolean",
          "description": "Disable automatic discovery of `example` targets.\n\nDisabling automatic discovery should only be needed for specialized\nsituations. For example, if you have a library where you want a *module* named\n`bin`, this would present a problem because Cargo would usually attempt to\ncompile anything in the `bin` directory as an executable. Here is a sample\nlayout of this scenario:\n\n```\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 bin\n        \u2514\u2500\u2500 mod.rs\n```\n",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery"
            }
          }
        },
        "autotests": {
          "type": "boolean",
          "description": "Disable automatic discovery of `test` targets.\n\nDisabling automatic discovery should only be needed for specialized\nsituations. For example, if you have a library where you want a *module* named\n`bin`, this would present a problem because Cargo would usually attempt to\ncompile anything in the `bin` directory as an executable. Here is a sample\nlayout of this scenario:\n\n```\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 lib.rs\n    \u2514\u2500\u2500 bin\n        \u2514\u2500\u2500 mod.rs\n```\n",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery"
            }
          }
        },
        "build": {
          "$ref": "#/definitions/Build"
        },
        "categories": {
          "anyOf": [
            {
              "$ref": "#/definitions/Categories"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `categories` field is an array of strings of the categories this package\nbelongs to.\n\n```toml\ncategories = [\"command-line-utilities\", \"development-tools::cargo-plugins\"]\n```\n\n> **Note**: [crates.io](https://crates.io) has a maximum of 5 categories. Each category should\n> match one of the strings available at https://crates.io/category_slugs, and\n> must match exactly.",
          "title": "Categories"
        },
        "default-run": {
          "type": "string",
          "description": "The `default-run` field in the `[package]` section of the manifest can be used\nto specify a default binary picked by [`cargo run`](https://doc.rust-lang.org/cargo/commands/cargo-run.html). For example, when there is\nboth `src/bin/a.rs` and `src/bin/b.rs`:\n\n```toml\n[package]\ndefault-run = \"a\"\n```",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-default-run-field"
            }
          }
        },
        "description": {
          "anyOf": [
            {
              "$ref": "#/definitions/Description"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The description is a short blurb about the package. [crates.io](https://crates.io) will display\nthis with your package. This should be plain text (not Markdown).\n\n```toml\n[package]\n# ...\ndescription = \"A short description of my package\"\n```\n\n> **Note**: [crates.io](https://crates.io) requires the `description` to be set.",
          "title": "Description"
        },
        "documentation": {
          "anyOf": [
            {
              "$ref": "#/definitions/Documentation"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "\nThe `documentation` field specifies a URL to a website hosting the crate's\ndocumentation. If no URL is specified in the manifest file, [crates.io](https://crates.io) will\nautomatically link your crate to the corresponding [docs.rs](https://docs.rs) page.\n\n```toml\n[package]\n# ...\ndocumentation = \"https://docs.rs/bitflags\"\n```\n",
          "title": "Documentation"
        },
        "edition": {
          "anyOf": [
            {
              "$ref": "#/definitions/Edition"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `edition` key affects which edition your package is compiled with. Cargo\nwill always generate packages via [`cargo new`](https://doc.rust-lang.org/cargo/commands/cargo-new.html) with the `edition` key set to the\nlatest edition. Setting the `edition` key in `[package]` will affect all\ntargets/crates in the package, including test suites, benchmarks, binaries,\nexamples, etc.",
          "title": "Edition"
        },
        "exclude": {
          "anyOf": [
            {
              "$ref": "#/definitions/Exclude"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "You can explicitly specify that a set of file patterns should be ignored or\nincluded for the purposes of packaging. The patterns specified in the\n`exclude` field identify a set of files that are not included, and the\npatterns in `include` specify files that are explicitly included.\n\nThe patterns should be [gitignore](https://git-scm.com/docs/gitignore)-style patterns. Briefly:\n\n- `foo` matches any file or directory with the name `foo` anywhere in the\n  package. This is equivalent to the pattern `**/foo`.\n- `/foo` matches any file or directory with the name `foo` only in the root of\n  the package.\n- `foo/` matches any *directory* with the name `foo` anywhere in the package.\n- Common glob patterns like `*`, `?`, and `[]` are supported:\n  - `*` matches zero or more characters except `/`.  For example, `*.html`\n    matches any file or directory with the `.html` extension anywhere in the\n    package.\n  - `?` matches any character except `/`. For example, `foo?` matches `food`,\n    but not `foo`.\n  - `[]` allows for matching a range of characters. For example, `[ab]`\n    matches either `a` or `b`. `[a-z]` matches letters a through z.\n- `**/` prefix matches in any directory. For example, `**/foo/bar` matches the\n  file or directory `bar` anywhere that is directly under directory `foo`.\n- `/**` suffix matches everything inside. For example, `foo/**` matches all\n  files inside directory `foo`, including all files in subdirectories below\n  `foo`.\n- `/**/` matches zero or more directories. For example, `a/**/b` matches\n  `a/b`, `a/x/b`, `a/x/y/b`, and so on.\n- `!` prefix negates a pattern. For example, a pattern of `src/**.rs` and\n  `!foo.rs` would match all files with the `.rs` extension inside the `src`\n  directory, except for any file named `foo.rs`.\n\nIf git is being used for a package, the `exclude` field will be seeded with\nthe `gitignore` settings from the repository.\n\n```toml\n[package]\n# ...\nexclude = [\"build/**/*.o\", \"doc/**/*.html\"]\n```\n\n```toml\n[package]\n# ...\ninclude = [\"src/**/*\", \"Cargo.toml\"]\n```\n\nThe options are mutually exclusive: setting `include` will override an\n`exclude`. Note that `include` must be an exhaustive list of files as otherwise\nnecessary source files may not be included. The package's `Cargo.toml` is\nautomatically included.\n\nThe include/exclude list is also used for change tracking in some situations.\nFor targets built with `rustdoc`, it is used to determine the list of files to\ntrack to determine if the target should be rebuilt. If the package has a\n[build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) that does not emit any `rerun-if-*` directives, then the\ninclude/exclude list is used for tracking if the build script should be re-run\nif any of those files change.",
          "title": "Exclude"
        },
        "homepage": {
          "anyOf": [
            {
              "$ref": "#/definitions/Homepage"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `homepage` field should be a URL to a site that is the home page for your\npackage.\n\n```toml\n[package]\n# ...\nhomepage = \"https://serde.rs/\"\n```",
          "title": "Homepage"
        },
        "im-a-teapot": {
          "type": "boolean",
          "description": "Sets whether the current package is a teapot or something else that is not capable of brewing tea.",
          "x-taplo": {
            "hidden": true
          }
        },
        "include": {
          "anyOf": [
            {
              "$ref": "#/definitions/Include"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "You can explicitly specify that a set of file patterns should be ignored or\nincluded for the purposes of packaging. The patterns specified in the\n`exclude` field identify a set of files that are not included, and the\npatterns in `include` specify files that are explicitly included.\n\nThe patterns should be [gitignore](https://git-scm.com/docs/gitignore)-style patterns. Briefly:\n\n- `foo` matches any file or directory with the name `foo` anywhere in the\n  package. This is equivalent to the pattern `**/foo`.\n- `/foo` matches any file or directory with the name `foo` only in the root of\n  the package.\n- `foo/` matches any *directory* with the name `foo` anywhere in the package.\n- Common glob patterns like `*`, `?`, and `[]` are supported:\n  - `*` matches zero or more characters except `/`.  For example, `*.html`\n    matches any file or directory with the `.html` extension anywhere in the\n    package.\n  - `?` matches any character except `/`. For example, `foo?` matches `food`,\n    but not `foo`.\n  - `[]` allows for matching a range of characters. For example, `[ab]`\n    matches either `a` or `b`. `[a-z]` matches letters a through z.\n- `**/` prefix matches in any directory. For example, `**/foo/bar` matches the\n  file or directory `bar` anywhere that is directly under directory `foo`.\n- `/**` suffix matches everything inside. For example, `foo/**` matches all\n  files inside directory `foo`, including all files in subdirectories below\n  `foo`.\n- `/**/` matches zero or more directories. For example, `a/**/b` matches\n  `a/b`, `a/x/b`, `a/x/y/b`, and so on.\n- `!` prefix negates a pattern. For example, a pattern of `src/**.rs` and\n  `!foo.rs` would match all files with the `.rs` extension inside the `src`\n  directory, except for any file named `foo.rs`.\n\nIf git is being used for a package, the `exclude` field will be seeded with\nthe `gitignore` settings from the repository.\n\n```toml\n[package]\n# ...\nexclude = [\"build/**/*.o\", \"doc/**/*.html\"]\n```\n\n```toml\n[package]\n# ...\ninclude = [\"src/**/*\", \"Cargo.toml\"]\n```\n\nThe options are mutually exclusive: setting `include` will override an\n`exclude`. Note that `include` must be an exhaustive list of files as otherwise\nnecessary source files may not be included. The package's `Cargo.toml` is\nautomatically included.\n\nThe include/exclude list is also used for change tracking in some situations.\nFor targets built with `rustdoc`, it is used to determine the list of files to\ntrack to determine if the target should be rebuilt. If the package has a\n[build script](https://doc.rust-lang.org/cargo/reference/build-scripts.html) that does not emit any `rerun-if-*` directives, then the\ninclude/exclude list is used for tracking if the build script should be re-run\nif any of those files change."
        },
        "keywords": {
          "anyOf": [
            {
              "$ref": "#/definitions/Keywords"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `keywords` field is an array of strings that describe this package. This\ncan help when searching for the package on a registry, and you may choose any\nwords that would help someone find this crate.\n\n```toml\n[package]\n# ...\nkeywords = [\"gamedev\", \"graphics\"]\n```\n\n> **Note**: [crates.io](https://crates.io) has a maximum of 5 keywords. Each keyword must be\n> ASCII text, start with a letter, and only contain letters, numbers, `_` or\n> `-`, and have at most 20 characters.",
          "title": "Keywords"
        },
        "license": {
          "anyOf": [
            {
              "$ref": "#/definitions/License"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `license` field contains the name of the software license that the package\nis released under.\n\n[crates.io](https://crates.io/) interprets the `license` field as an [SPDX 2.1 license\nexpression](https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60). The name must be a known license\nfrom the [SPDX license list 3.6](https://github.com/spdx/license-list-data/tree/v3.6). Parentheses are not\ncurrently supported. See the [SPDX site](https://spdx.org/license-list) for more information.\n\nSPDX license expressions support AND and OR operators to combine multiple\nlicenses.\n\n```toml\n[package]\n# ...\nlicense = \"MIT OR Apache-2.0\"\n```\n\nUsing `OR` indicates the user may choose either license. Using `AND` indicates\nthe user must comply with both licenses simultaneously. The `WITH` operator\nindicates a license with a special exception. Some examples:\n\n* `MIT OR Apache-2.0`\n* `LGPL-2.1 AND MIT AND BSD-2-Clause`\n* `GPL-2.0+ WITH Bison-exception-2.2`\n\nIf a package is using a nonstandard license, then the `license-file` field may\nbe specified in lieu of the `license` field.",
          "title": "License"
        },
        "license-file": {
          "anyOf": [
            {
              "$ref": "#/definitions/LicenseFile"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `license-file` field contains the path to a file\ncontaining the text of the license (relative to this `Cargo.toml`).\n\n```toml\n[package]\n# ...\nlicense-file = \"LICENSE.txt\"\n```\n\n> **Note**: [crates.io](https://crates.io) requires either `license` or `license-file` to be set.",
          "title": "LicenseFile"
        },
        "links": {
          "type": "string",
          "description": "The `links` field specifies the name of a native library that is being linked\nto. More information can be found in the [`links`](https://doc.rust-lang.org/cargo/reference/build-scripts.html#the-links-manifest-key) section of the build\nscript guide.\n\n```toml\n[package]\n# ...\nlinks = \"foo\"\n```",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-links-field"
            }
          }
        },
        "metabuild": {
          "$ref": "#/definitions/MetaBuild",
          "x-taplo": {
            "hidden": true
          }
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "description": "Cargo by default will warn about unused keys in `Cargo.toml` to assist in\ndetecting typos and such. The `package.metadata` table, however, is completely\nignored by Cargo and will not be warned about. This section can be used for\ntools which would like to store package configuration in `Cargo.toml`. For\nexample:\n\n```toml\n[package]\nname = \"...\"\n# ...\n\n# Metadata used when generating an Android APK, for example.\n[package.metadata.android]\npackage-name = \"my-awesome-android-app\"\nassets = \"path/to/static\"\n```\n",
          "properties": {
            "playdate": {
              "$ref": "#/definitions/PlaydateMetadata"
            }
          },
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-metadata-table"
            }
          },
          "x-tombi-table-keys-order": "schema"
        },
        "namespaced-features": {
          "type": "boolean",
          "x-taplo": {
            "hidden": true
          }
        },
        "publish": {
          "anyOf": [
            {
              "$ref": "#/definitions/Publish"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `publish` field can be used to prevent a package from being published to a package registry (like *crates.io*) by mistake, for instance to keep a package\nprivate in a company.\n\n```toml\n[package]\n# ...\npublish = false\n```\n\nThe value may also be an array of strings which are registry names that are\nallowed to be published to.\n\n```toml\n[package]\n# ...\npublish = [\"some-registry-name\"]\n```",
          "title": "Publish"
        },
        "publish-lockfile": {
          "type": "boolean",
          "x-taplo": {
            "hidden": true
          }
        },
        "readme": {
          "anyOf": [
            {
              "$ref": "#/definitions/Readme"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `readme` field should be the path to a file in the package root (relative\nto this `Cargo.toml`) that contains general information about the package.\nThis file will be transferred to the registry when you publish. [crates.io](https://crates.io)\nwill interpret it as Markdown and render it on the crate's page.\n\n```toml\n[package]\n# ...\nreadme = \"README.md\"\n```\n\nIf no value is specified for this field, and a file named `README.md`,\n`README.txt` or `README` exists in the package root, then the name of that\nfile will be used. You can suppress this behavior by setting this field to\n`false`. If the field is set to `true`, a default value of `README.md` will\nbe assumed.\n",
          "title": "Readme"
        },
        "repository": {
          "anyOf": [
            {
              "$ref": "#/definitions/Repository"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `repository` field should be a URL to the source repository for your\npackage.\n\n```toml\n[package]\n# ...\nrepository = \"https://github.com/rust-lang/cargo/\"\n```",
          "title": "Repository"
        },
        "resolver": {
          "$ref": "#/definitions/Resolver"
        },
        "rust-version": {
          "anyOf": [
            {
              "$ref": "#/definitions/RustVersion"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "The `rust-version` field is an optional key that tells cargo what version of the\nRust language and compiler your package can be compiled with. If the currently\nselected version of the Rust compiler is older than the stated version, cargo\nwill exit with an error, telling the user what version is required.\n\nThe first version of Cargo that supports this field was released with Rust 1.56.0.\nIn older releases, the field will be ignored, and Cargo will display a warning.\n\n```toml\n[package]\n# ...\nrust-version = \"1.56\"\n```\n\nThe Rust version must be a bare version number with two or three components; it\ncannot include semver operators or pre-release identifiers. Compiler pre-release\nidentifiers such as -nightly will be ignored while checking the Rust version.\nThe `rust-version` must be equal to or newer than the version that first\nintroduced the configured `edition`.\n\nThe `rust-version` may be ignored using the `--ignore-rust-version` option.\n\nSetting the `rust-version` key in `[package]` will affect all targets/crates in\nthe package, including test suites, benchmarks, binaries, examples, etc.",
          "title": "RustVersion"
        },
        "version": {
          "anyOf": [
            {
              "$ref": "#/definitions/SemVer"
            },
            {
              "$ref": "#/definitions/WorkspaceInheritance"
            }
          ],
          "description": "Cargo bakes in the concept of [Semantic Versioning](https://semver.org/), so make sure you follow some basic rules:\n\n* Before you reach 1.0.0, anything goes, but if you make breaking changes,\n    increment the minor version. In Rust, breaking changes include adding fields to\n    structs or variants to enums.\n* After 1.0.0, only make breaking changes when you increment the major version.\n    Don't break the build.\n* After 1.0.0, don't add any new public API (no new `pub` anything) in patch-level\n    versions. Always increment the minor version if you add any new `pub` structs,\n    traits, fields, types, functions, methods or anything else.\n* Use version numbers with three numeric parts such as 1.0.0 rather than 1.0.",
          "title": "Semantic Version"
        },
        "workspace": {
          "type": "string",
          "description": "The `workspace` field can be used to configure the workspace that this package\nwill be a member of. If not specified this will be inferred as the first\nCargo.toml with `[workspace]` upwards in the filesystem. Setting this is\nuseful if the member is not inside a subdirectory of the workspace root.\n\n```toml\n[package]\n# ...\nworkspace = \"path/to/workspace/root\"\n```\n\nThis field cannot be specified if the manifest already has a `[workspace]`\ntable defined. That is, a crate cannot both be a root crate in a workspace\n(contain `[workspace]`) and also be a member crate of another workspace\n(contain `package.workspace`).\n\nFor more information, see the [workspaces chapter](https://doc.rust-lang.org/cargo/reference/workspaces.html).",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-workspace-field"
            }
          }
        }
      },
      "required": [
        "name"
      ],
      "title": "Package",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-package-section"
        }
      },
      "x-tombi-table-keys-order": "schema"
    },
    "Panic": {
      "type": "string",
      "description": "The `panic` setting controls the [`-C panic` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#panic) which controls which panic\nstrategy to use.\n\nWhen set to `\"unwind\"`, the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses `\"abort\"`.\n\nTests, benchmarks, build scripts, and proc macros ignore the `panic` setting.\nThe `rustc` test harness currently requires `unwind` behavior. See the\n[`panic-abort-tests`](https://doc.rust-lang.org/cargo/reference/unstable.html#panic-abort-tests) unstable flag which enables `abort` behavior.\n\nAdditionally, when using the `abort` strategy and building a test, all of the\ndependencies will also be forced to built with the `unwind` strategy.",
      "enum": [
        "unwind",
        "abort"
      ],
      "title": "Panic",
      "x-taplo": {
        "docs": {
          "enumValues": [
            "Unwind the stack upon panic.",
            "Terminate the process upon panic."
          ]
        },
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#panic"
        }
      }
    },
    "Platform": {
      "type": "object",
      "properties": {
        "build-dependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Dependency"
          },
          "description": "You can depend on other Cargo-based crates for use in your build scripts.\nDependencies are declared through the `build-dependencies` section of the\nmanifest:\n\n```toml\n[build-dependencies]\ncc = \"1.0.3\"\n```\n\nThe build script **does not** have access to the dependencies listed\nin the `dependencies` or `dev-dependencies` section. Build\ndependencies will likewise not be available to the package itself\nunless listed under the `dependencies` section as well. A package\nitself and its build script are built separately, so their\ndependencies need not coincide. Cargo is kept simpler and cleaner by\nusing independent dependencies for independent purposes.",
          "x-taplo": {
            "crates": {
              "schemas": "dependencies"
            },
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#build-dependencies"
            },
            "plugins": [
              "crates"
            ]
          },
          "x-tombi-table-keys-order": "version-sort"
        },
        "build_dependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Dependency"
          },
          "x-taplo": {
            "hidden": true
          },
          "x-tombi-table-keys-order": "version-sort"
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Dependency"
          },
          "description": "Cargo is configured to look for dependencies on [crates.io](https://crates.io) by default. Only\nthe name and a version string are required in this case. In [the cargo\nguide](https://doc.rust-lang.org/cargo/guide/index.html), we specified a dependency on the `time` crate:\n\n```toml\n[dependencies]\ntime = \"0.1.12\"\n```\n\nThe string `\"0.1.12\"` is a [semver](https://github.com/steveklabnik/semver#requirements) version requirement. Since this\nstring does not have any operators in it, it is interpreted the same way as\nif we had specified `\"^0.1.12\"`, which is called a caret requirement.\n\nA dependency can also be defined by a table with additional options:\n\n```toml\n[dependencies]\ntime = { path = \"../time\", version = \"0.1.12\" }\n```",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html"
            }
          },
          "x-tombi-table-keys-order": "version-sort"
        },
        "dev-dependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Dependency"
          },
          "description": "The format of `[dev-dependencies]` is equivalent to `[dependencies]`:\n\n```toml\n[dev-dependencies]\ntempdir = \"0.3\"\n```\n\nDev-dependencies are not used when compiling\na package for building, but are used for compiling tests, examples, and\nbenchmarks.\n\nThese dependencies are *not* propagated to other packages which depend on this\npackage.\n\nYou can also have target-specific development dependencies by using\n`dev-dependencies` in the target section header instead of `dependencies`. For\nexample:\n\n```toml\n[target.'cfg(unix)'.dev-dependencies]\nmio = \"0.0.1\"\n```\n\n> **Note**: When a package is published, only dev-dependencies that specify a\n> `version` will be included in the published crate. For most use cases,\n> dev-dependencies are not needed when published, though some users (like OS\n> packagers) may want to run tests within a crate, so providing a `version` if\n> possible can still be beneficial.\n",
          "x-taplo": {
            "crates": {
              "schemas": "dependencies"
            },
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies"
            },
            "plugins": [
              "crates"
            ]
          },
          "x-tombi-table-keys-order": "version-sort"
        },
        "dev_dependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Dependency"
          },
          "x-taplo": {
            "hidden": true
          },
          "x-tombi-table-keys-order": "version-sort"
        }
      },
      "title": "Platform",
      "x-tombi-table-keys-order": "schema"
    },
    "PlaydateMetadata": {
      "type": "object",
      "additionalProperties": false,
      "description": "Metadata and build configuration.",
      "properties": {
        "name": {
          "type": "string",
          "description": "A game version number, formatted any way you wish, that is displayed to players. It is not used to compute when updates should occur.",
          "x-taplo": {
            "links": {
              "key": "https://sdk.play.date/#pdxinfo"
            }
          }
        },
        "assets": {
          "anyOf": [
            {
              "$ref": "#/definitions/PlaydateMetadataAssetsMap"
            },
            {
              "$ref": "#/definitions/PlaydateMetadataAssetsArray"
            }
          ]
        },
        "author": {
          "type": "string",
          "x-taplo": {
            "links": {
              "key": "https://sdk.play.date/#pdxinfo"
            }
          }
        },
        "build-number": {
          "type": "integer",
          "description": "A monotonically-increasing integer value used to indicate a unique version of your game. This can be set using an automated build process like Continuous Integration to avoid having to set the value by hand.\n\nFor sideloaded games, buildNumber is required and is used to determine when a newer version is available to download.",
          "exclusiveMinimum": 0,
          "x-taplo": {
            "links": {
              "key": "https://sdk.play.date/#pdxinfo"
            }
          }
        },
        "bundle-id": {
          "type": "string",
          "description": "A unique identifier for your game, in reverse DNS notation.",
          "x-taplo": {
            "links": {
              "key": "https://sdk.play.date/#pdxinfo"
            }
          }
        },
        "content-warning": {
          "type": "string",
          "description": "Optional. A content warning that displays when the user launches your game for the first time. The user will have the option of backing out and not launching your game if they choose.",
          "x-taplo": {
            "links": {
              "key": "https://sdk.play.date/#pdxinfo"
            }
          }
        },
        "content-warning2": {
          "type": "string",
          "description": "Optional. A second content warning that displays on a second screen when the user launches your game for the first time. The user will have the option of backing out and not launching your game if they choose.\n\nNote: `content-warning2` will only display if a `content-warning` attribute is also specified.\n\nThe string displayed on the content warning screen can only be so long before it will be truncated with an \"\u2026\" character. Be sure to keep this in mind when designing your `content-warning` and `content-warning2` text.",
          "x-taplo": {
            "links": {
              "key": "https://sdk.play.date/#pdxinfo"
            }
          }
        },
        "description": {
          "type": "string",
          "x-taplo": {
            "links": {
              "key": "https://sdk.play.date/#pdxinfo"
            }
          }
        },
        "dev-assets": {
          "anyOf": [
            {
              "$ref": "#/definitions/PlaydateMetadataAssetsMap"
            },
            {
              "$ref": "#/definitions/PlaydateMetadataAssetsArray"
            }
          ]
        },
        "image-path": {
          "type": "string",
          "description": "A directory of images that will be used by the launcher.\n\nMore in [official documentation](https://sdk.play.date/#pdxinfo).",
          "x-taplo": {
            "links": {
              "key": "https://sdk.play.date/#pdxinfo"
            }
          }
        },
        "launch-sound-path": {
          "type": "string",
          "description": "Should point to the path of a short audio file to be played as the game launch animation is taking place.\n\nMore in [official documentation](https://sdk.play.date/#pdxinfo).",
          "x-taplo": {
            "links": {
              "key": "https://sdk.play.date/#pdxinfo"
            }
          }
        },
        "options": {
          "$ref": "#/definitions/PlaydateMetadataOptions"
        },
        "support": {
          "type": "object",
          "additionalProperties": true,
          "properties": {}
        },
        "version": {
          "type": "string",
          "x-taplo": {
            "links": {
              "key": "https://sdk.play.date/#pdxinfo"
            }
          }
        }
      },
      "required": [
        "bundle-id"
      ],
      "title": "Playdate Package Metadata",
      "x-taplo": {
        "initKeys": [
          "bundle-id",
          "name",
          "description",
          "author",
          "image-path",
          "launch-sound-path"
        ],
        "links": {
          "key": "https://sdk.play.date/#pdxinfo"
        }
      },
      "x-taplo-info": {
        "authors": [
          "Alex Koz. (https://github.com/boozook)"
        ]
      },
      "x-tombi-table-keys-order": "schema"
    },
    "PlaydateMetadataAssetsArray": {
      "type": "array",
      "description": "List of paths to include.",
      "items": {
        "type": "string",
        "description": "Path to include.",
        "title": "Path"
      },
      "title": "Assets list",
      "uniqueItems": true,
      "x-taplo": {
        "links": {
          "key": "https://github.com/boozook/playdate/blob/main/support/build/README.md#assets-list"
        }
      },
      "x-tombi-array-values-order": "version-sort"
    },
    "PlaydateMetadataAssetsMap": {
      "type": "object",
      "additionalProperties": {
        "anyOf": [
          {
            "type": "string",
            "description": "Path of files to include. Can be absolute, relative to the crate root, or/and glob.\n\nLeft hand is where to put files, path in the resulting package.\n\nRight hand is a path or pattern to match files to include.",
            "title": "Path"
          },
          {
            "type": "boolean",
            "description": "Include or exclude the file or glob-pattern.",
            "title": "Include"
          }
        ]
      },
      "description": "Rules used to resolve paths to include.",
      "properties": {
        "options": {
          "$ref": "#/definitions/PlaydateMetadataAssetsOptions"
        }
      },
      "title": "Assets rules",
      "x-taplo": {
        "links": {
          "key": "https://github.com/boozook/playdate/blob/main/support/build/README.md#assets-table"
        }
      },
      "x-tombi-table-keys-order": "schema"
    },
    "PlaydateMetadataAssetsOptions": {
      "type": "object",
      "additionalProperties": false,
      "description": "Options for assets paths resolution and how to build assets collection",
      "properties": {
        "dependencies": {
          "type": "boolean",
          "description": "Allow build assets for dependencies."
        },
        "follow-symlinks": {
          "type": "boolean"
        },
        "method": {
          "type": "string",
          "enum": [
            "copy",
            "link"
          ]
        },
        "overwrite": {
          "type": "boolean",
          "description": "Allow overwriting existing files."
        }
      },
      "title": "Assets Configuration",
      "x-taplo": {
        "links": {
          "key": "https://github.com/boozook/playdate/blob/main/support/build/README.md#assets-options"
        }
      },
      "x-tombi-table-keys-order": "schema"
    },
    "PlaydateMetadataOptions": {
      "type": "object",
      "additionalProperties": true,
      "description": "Package build options.",
      "properties": {
        "assets": {
          "$ref": "#/definitions/PlaydateMetadataAssetsOptions"
        }
      },
      "title": "Configuration",
      "x-taplo": {
        "links": {
          "key": "https://github.com/boozook/playdate/blob/main/support/build/README.md#options"
        }
      },
      "x-tombi-table-keys-order": "schema"
    },
    "Profile": {
      "type": "object",
      "properties": {
        "codegen-units": {
          "$ref": "#/definitions/CodegenUnits"
        },
        "debug": {
          "$ref": "#/definitions/DebugLevel"
        },
        "debug-assertions": {
          "$ref": "#/definitions/DebugAssertions"
        },
        "dir-name": {
          "type": "string",
          "x-taplo": {
            "hidden": true
          }
        },
        "incremental": {
          "$ref": "#/definitions/Incremental"
        },
        "inherits": {
          "$ref": "#/definitions/Inherits"
        },
        "lto": {
          "$ref": "#/definitions/Lto"
        },
        "opt-level": {
          "$ref": "#/definitions/OptLevel"
        },
        "overflow-checks": {
          "$ref": "#/definitions/OverflowChecks"
        },
        "package": {
          "$ref": "#/definitions/ProfilePackageOverrides"
        },
        "panic": {
          "$ref": "#/definitions/Panic"
        },
        "rpath": {
          "$ref": "#/definitions/Rpath"
        },
        "split-debuginfo": {
          "$ref": "#/definitions/SplitDebuginfo"
        },
        "strip": {
          "$ref": "#/definitions/Strip"
        }
      },
      "title": "Profile",
      "x-tombi-table-keys-order": "schema"
    },
    "ProfilePackageOverrides": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Profile"
      },
      "description": "Package-specific overrides.\n\nThe package name is a [Package ID Spec](https://doc.rust-lang.org/cargo/reference/pkgid-spec.html), so you can\ntarget individual versions of a package with syntax such as `[profile.dev.package.\"foo:2.1.0\"]`.",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#overrides"
        }
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "ProfileWithBuildOverride": {
      "type": "object",
      "properties": {
        "build-override": {
          "$ref": "#/definitions/Profile"
        },
        "codegen-units": {
          "$ref": "#/definitions/CodegenUnits"
        },
        "debug": {
          "$ref": "#/definitions/DebugLevel"
        },
        "debug-assertions": {
          "$ref": "#/definitions/DebugAssertions"
        },
        "incremental": {
          "$ref": "#/definitions/Incremental"
        },
        "inherits": {
          "$ref": "#/definitions/Inherits"
        },
        "lto": {
          "$ref": "#/definitions/Lto"
        },
        "opt-level": {
          "$ref": "#/definitions/OptLevel"
        },
        "overflow-checks": {
          "$ref": "#/definitions/OverflowChecks"
        },
        "package": {
          "$ref": "#/definitions/ProfilePackageOverrides"
        },
        "panic": {
          "$ref": "#/definitions/Panic"
        },
        "rpath": {
          "$ref": "#/definitions/Rpath"
        },
        "split-debuginfo": {
          "$ref": "#/definitions/SplitDebuginfo"
        },
        "strip": {
          "$ref": "#/definitions/Strip"
        }
      },
      "title": "Profile with Build Override",
      "x-tombi-table-keys-order": "schema"
    },
    "Profiles": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/ProfileWithBuildOverride"
      },
      "description": "Profiles provide a way to alter the compiler settings, influencing things like optimizations and debugging symbols.\n\nCargo has 4 built-in profiles: dev, release, test, and bench. It automatically chooses the profile based on which command is being run, the package and target that is being built, and command-line flags like --release.",
      "properties": {
        "bench": {
          "$ref": "#/definitions/ProfileWithBuildOverride"
        },
        "dev": {
          "$ref": "#/definitions/ProfileWithBuildOverride"
        },
        "release": {
          "$ref": "#/definitions/ProfileWithBuildOverride"
        },
        "test": {
          "$ref": "#/definitions/ProfileWithBuildOverride"
        }
      },
      "title": "Profiles",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html"
        }
      }
    },
    "Publish": {
      "anyOf": [
        {
          "type": "boolean",
          "default": true,
          "description": "A boolean indicating whether the package can be published.",
          "enum": [
            true,
            false
          ],
          "x-taplo": {
            "docs": {
              "enumValues": [
                "The package can be published.",
                "The package cannot be published."
              ]
            }
          }
        },
        {
          "type": "array",
          "description": "An array of registry names.",
          "items": {
            "type": "string"
          },
          "uniqueItems": true,
          "x-tombi-array-values-order": "version-sort"
        }
      ],
      "description": "The `publish` field can be used to prevent a package from being published to a package registry (like *crates.io*) by mistake, for instance to keep a package\nprivate in a company.\n\n```toml\n[package]\n# ...\npublish = false\n```\n\nThe value may also be an array of strings which are registry names that are\nallowed to be published to.\n\n```toml\n[package]\n# ...\npublish = [\"some-registry-name\"]\n```",
      "title": "Publish",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish-field"
        }
      }
    },
    "Readme": {
      "anyOf": [
        {
          "type": "string",
          "description": "The `readme` field should be the path to a file in the package root (relative\nto this `Cargo.toml`) that contains general information about the package."
        },
        {
          "type": "boolean",
          "enum": [
            true,
            false
          ],
          "x-taplo": {
            "docs": {
              "enumValues": [
                "Use the `README.md` file.",
                "Do not use the default `README.md` file"
              ]
            }
          }
        }
      ],
      "description": "The `readme` field should be the path to a file in the package root (relative\nto this `Cargo.toml`) that contains general information about the package.\nThis file will be transferred to the registry when you publish. [crates.io](https://crates.io)\nwill interpret it as Markdown and render it on the crate's page.\n\n```toml\n[package]\n# ...\nreadme = \"README.md\"\n```\n\nIf no value is specified for this field, and a file named `README.md`,\n`README.txt` or `README` exists in the package root, then the name of that\nfile will be used. You can suppress this behavior by setting this field to\n`false`. If the field is set to `true`, a default value of `README.md` will\nbe assumed.\n",
      "title": "Readme",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-readme-field"
        }
      }
    },
    "Repository": {
      "type": "string",
      "description": "The `repository` field should be a URL to the source repository for your\npackage.\n\n```toml\n[package]\n# ...\nrepository = \"https://github.com/rust-lang/cargo/\"\n```",
      "title": "Repository",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-repository-field"
        }
      }
    },
    "Resolver": {
      "type": "string",
      "description": "A different feature resolver algorithm can be used by specifying the resolver version in Cargo.toml like this:\n\n[package]\nname = \"my-package\"\nversion = \"1.0.0\"\nresolver = \"2\"\n\nThe version \"1\" resolver is the original resolver that shipped with Cargo up to version 1.50. The default is \"2\" if the root package specifies edition = \"2021\" or a newer edition. Otherwise the default is \"1\".\n\nThe version \"2\" resolver introduces changes in feature unification. See the features chapter for more details.\n\nThe resolver is a global option that affects the entire workspace. The resolver version in dependencies is ignored, only the value in the top-level package will be used. If using a virtual workspace, the version should be specified in the [workspace] table, for example:\n\n[workspace]\nmembers = [\"member1\", \"member2\"]\nresolver = \"2\"",
      "enum": [
        "1",
        "2",
        "3"
      ],
      "title": "Resolver",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions"
        }
      }
    },
    "Rpath": {
      "type": "boolean",
      "description": "The `rpath` setting controls the [`-C rpath` flag](https://doc.rust-lang.org/rustc/codegen-options/index.html#rpath) which controls\nwhether or not [`rpath`](https://en.wikipedia.org/wiki/Rpath) is enabled.",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#rpath"
        }
      }
    },
    "RustVersion": {
      "type": "string",
      "description": "The `rust-version` field is an optional key that tells cargo what version of the\nRust language and compiler your package can be compiled with. If the currently\nselected version of the Rust compiler is older than the stated version, cargo\nwill exit with an error, telling the user what version is required.\n\nThe first version of Cargo that supports this field was released with Rust 1.56.0.\nIn older releases, the field will be ignored, and Cargo will display a warning.\n\n```toml\n[package]\n# ...\nrust-version = \"1.56\"\n```\n\nThe Rust version must be a bare version number with two or three components; it\ncannot include semver operators or pre-release identifiers. Compiler pre-release\nidentifiers such as -nightly will be ignored while checking the Rust version.\nThe `rust-version` must be equal to or newer than the version that first\nintroduced the configured `edition`.\n\nThe `rust-version` may be ignored using the `--ignore-rust-version` option.\n\nSetting the `rust-version` key in `[package]` will affect all targets/crates in\nthe package, including test suites, benchmarks, binaries, examples, etc.",
      "title": "RustVersion",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field"
        }
      }
    },
    "SemVer": {
      "type": "string",
      "default": "0.1.0",
      "description": "Cargo bakes in the concept of [Semantic Versioning](https://semver.org/), so make sure you follow some basic rules:\n\n* Before you reach 1.0.0, anything goes, but if you make breaking changes,\n    increment the minor version. In Rust, breaking changes include adding fields to\n    structs or variants to enums.\n* After 1.0.0, only make breaking changes when you increment the major version.\n    Don't break the build.\n* After 1.0.0, don't add any new public API (no new `pub` anything) in patch-level\n    versions. Always increment the minor version if you add any new `pub` structs,\n    traits, fields, types, functions, methods or anything else.\n* Use version numbers with three numeric parts such as 1.0.0 rather than 1.0.",
      "format": "semver",
      "title": "Semantic Version",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-version-field"
        }
      }
    },
    "SemVerRequirement": {
      "type": "string",
      "default": "*",
      "description": "The [version requirement](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) of the target dependency.",
      "format": "semver-requirement",
      "title": "Semantic Version Requirement",
      "x-taplo": {
        "crates": {
          "schemas": "version"
        },
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html"
        },
        "plugins": [
          "crates"
        ]
      }
    },
    "SplitDebuginfo": {
      "description": "The split-debuginfo setting controls the -C split-debuginfo flag which controls whether debug information, if generated, is either placed in the executable itself or adjacent to it. This can be useful for reducing the size of the executable, but may make it harder to debug the executable.",
      "oneOf": [
        {
          "type": "string",
          "description": "This is the default for platforms with ELF binaries and windows-gnu (not Windows MSVC and not macOS). This typically means that DWARF debug information can be found in the final artifact in sections of the executable. This option is not supported on Windows MSVC. On macOS this options prevents the final execution of dsymutil to generate debuginfo.",
          "enum": [
            "off"
          ]
        },
        {
          "type": "string",
          "description": "This is the default for Windows MSVC and macOS. The term \"packed\" here means that all the debug information is packed into a separate file from the main executable. On Windows MSVC this is a *.pdb file, on macOS this is a *.dSYM folder, and on other platforms this is a *.dwp file.",
          "enum": [
            "packed"
          ]
        },
        {
          "type": "string",
          "description": "This means that debug information will be found in separate files for each compilation unit (object file). This is not supported on Windows MSVC. On macOS this means the original object files will contain debug information. On other Unix platforms this means that *.dwo files will contain debug information.",
          "enum": [
            "unpacked"
          ]
        }
      ],
      "title": "SplitDebuginfo",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#split-debuginfo"
        }
      }
    },
    "Strip": {
      "oneOf": [
        {
          "type": "string",
          "default": "none",
          "description": "The strip option controls the -C strip flag, which directs rustc to strip either symbols or debuginfo from a binary.",
          "enum": [
            "none",
            "debuginfo",
            "symbols"
          ]
        },
        {
          "type": "boolean",
          "description": "The strip option controls the -C strip flag, which directs rustc to strip either symbols or debuginfo from a binary.",
          "enum": [
            true
          ],
          "title": "Equivalent to \"symbols\""
        },
        {
          "type": "boolean",
          "description": "The strip option controls the -C strip flag, which directs rustc to strip either symbols or debuginfo from a binary.",
          "enum": [
            false
          ],
          "title": "Equivalent to \"none\""
        }
      ],
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/profiles.html#strip"
        }
      }
    },
    "Target": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The `name` field specifies the name of the target, which corresponds to the\nfilename of the artifact that will be generated. For a library, this is the\ncrate name that dependencies will use to reference it.\n\nFor the `[lib]` and the default binary (`src/main.rs`), this defaults to the\nname of the package, with any dashes replaced with underscores. For other\n[auto discovered](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) targets, it defaults to the\ndirectory or file name.\n\nThis is required for all targets except `[lib]`.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-name-field"
            }
          }
        },
        "bench": {
          "type": "boolean",
          "description": "The `bench` field indicates whether or not the target is benchmarked by\ndefault by [`cargo bench`](https://doc.rust-lang.org/cargo/commands/cargo-bench.html). The default is `true` for lib, bins, and\nbenchmarks.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-bench-field"
            }
          }
        },
        "crate-type": {
          "type": "array",
          "description": "The `crate-type` field defines the [crate types](https://doc.rust-lang.org/reference/linkage.html) that will be generated by the\ntarget. It is an array of strings, allowing you to specify multiple crate\ntypes for a single target. This can only be specified for libraries and\nexamples. Binaries, tests, and benchmarks are always the \"bin\" crate type.\n\nThe available options are `bin`, `lib`, `rlib`, `dylib`, `cdylib`,\n`staticlib`, and `proc-macro`. You can read more about the different crate\ntypes in the [Rust Reference Manual](https://doc.rust-lang.org/reference/linkage.html).",
          "items": {
            "type": "string",
            "description": "The `crate-type` field defines the [crate types](https://doc.rust-lang.org/reference/linkage.html) that will be generated by the\ntarget. It is an array of strings, allowing you to specify multiple crate\ntypes for a single target. This can only be specified for libraries and\nexamples. Binaries, tests, and benchmarks are always the \"bin\" crate type.\n\nThe available options are `bin`, `lib`, `rlib`, `dylib`, `cdylib`,\n`staticlib`, and `proc-macro`. You can read more about the different crate\ntypes in the [Rust Reference Manual](https://doc.rust-lang.org/reference/linkage.html).",
            "x-taplo": {
              "docs": {
                "enumValues": [
                  "A runnable executable will be produced. This requires that there is a `main` function in the crate which\nwill be run when the program begins executing. This will link in all Rust and\nnative dependencies, producing a distributable binary.",
                  "A Rust library will be produced.\nThis is an ambiguous concept as to what exactly is produced because a library\ncan manifest itself in several forms. The purpose of this generic `lib` option\nis to generate the \"compiler recommended\" style of library. The output library\nwill always be usable by rustc, but the actual type of library may change from\ntime-to-time. The remaining output types are all different flavors of\nlibraries, and the `lib` type can be seen as an alias for one of them (but the\nactual one is compiler-defined).",
                  "A \"Rust library\" file will be produced. This is used as an intermediate artifact and can be thought of as a\n\"static Rust library\". These `rlib` files, unlike `staticlib` files, are\ninterpreted by the compiler in future linkage. This essentially means\nthat `rustc` will look for metadata in `rlib` files like it looks for metadata\nin dynamic libraries. This form of output is used to produce statically linked\nexecutables as well as `staticlib` outputs.",
                  "A dynamic Rust library will be produced. This is different from the `lib` output type in that this forces\ndynamic library generation. The resulting dynamic library can be used as a\ndependency for other libraries and/or executables. This output type will\ncreate `*.so` files on linux, `*.dylib` files on osx, and `*.dll` files on\nwindows.",
                  "A dynamic system library will be produced. This is used when compiling\na dynamic library to be loaded from another language.  This output type will\ncreate `*.so` files on Linux, `*.dylib` files on macOS, and `*.dll` files on\nWindows.",
                  "A static system library will be produced. This is different from other library outputs in that\nthe compiler will never attempt to link to `staticlib` outputs. The\npurpose of this output type is to create a static library containing all of\nthe local crate's code along with all upstream dependencies. The static\nlibrary is actually a `*.a` archive on linux and osx and a `*.lib` file on\nwindows. This format is recommended for use in situations such as linking\nRust code into an existing non-Rust application because it will not have\ndynamic dependencies on other Rust code.",
                  "The output produced is not specified, but if a `-L` path is provided to it then the\ncompiler will recognize the output artifacts as a macro and it can be loaded\nfor a program. Crates compiled with this crate type  must only export\n[procedural macros](https://doc.rust-lang.org/reference/procedural-macros.html). The compiler will automatically set the `proc_macro`\n[configuration option](https://doc.rust-lang.org/reference/conditional-compilation.html). The crates are always compiled with the same target\nthat the compiler itself was built with. For example, if you are executing\nthe compiler from Linux with an `x86_64` CPU, the target will be\n`x86_64-unknown-linux-gnu` even if the crate is a dependency of another crate\nbeing built for a different target."
                ]
              },
              "links": {
                "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-crate-type-field"
              }
            }
          },
          "uniqueItems": true,
          "x-taplo": {
            "docs": {
              "enumValues": [
                "A runnable executable will be produced. This requires that there is a `main` function in the crate which\nwill be run when the program begins executing. This will link in all Rust and\nnative dependencies, producing a distributable binary.",
                "A Rust library will be produced.\nThis is an ambiguous concept as to what exactly is produced because a library\ncan manifest itself in several forms. The purpose of this generic `lib` option\nis to generate the \"compiler recommended\" style of library. The output library\nwill always be usable by rustc, but the actual type of library may change from\ntime-to-time. The remaining output types are all different flavors of\nlibraries, and the `lib` type can be seen as an alias for one of them (but the\nactual one is compiler-defined).",
                "A \"Rust library\" file will be produced. This is used as an intermediate artifact and can be thought of as a\n\"static Rust library\". These `rlib` files, unlike `staticlib` files, are\ninterpreted by the compiler in future linkage. This essentially means\nthat `rustc` will look for metadata in `rlib` files like it looks for metadata\nin dynamic libraries. This form of output is used to produce statically linked\nexecutables as well as `staticlib` outputs.",
                "A dynamic Rust library will be produced. This is different from the `lib` output type in that this forces\ndynamic library generation. The resulting dynamic library can be used as a\ndependency for other libraries and/or executables. This output type will\ncreate `*.so` files on linux, `*.dylib` files on osx, and `*.dll` files on\nwindows.",
                "A dynamic system library will be produced. This is used when compiling\na dynamic library to be loaded from another language.  This output type will\ncreate `*.so` files on Linux, `*.dylib` files on macOS, and `*.dll` files on\nWindows.",
                "A static system library will be produced. This is different from other library outputs in that\nthe compiler will never attempt to link to `staticlib` outputs. The\npurpose of this output type is to create a static library containing all of\nthe local crate's code along with all upstream dependencies. The static\nlibrary is actually a `*.a` archive on linux and osx and a `*.lib` file on\nwindows. This format is recommended for use in situations such as linking\nRust code into an existing non-Rust application because it will not have\ndynamic dependencies on other Rust code.",
                "The output produced is not specified, but if a `-L` path is provided to it then the\ncompiler will recognize the output artifacts as a macro and it can be loaded\nfor a program. Crates compiled with this crate type  must only export\n[procedural macros](https://doc.rust-lang.org/reference/procedural-macros.html). The compiler will automatically set the `proc_macro`\n[configuration option](https://doc.rust-lang.org/reference/conditional-compilation.html). The crates are always compiled with the same target\nthat the compiler itself was built with. For example, if you are executing\nthe compiler from Linux with an `x86_64` CPU, the target will be\n`x86_64-unknown-linux-gnu` even if the crate is a dependency of another crate\nbeing built for a different target."
              ]
            },
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-crate-type-field"
            }
          },
          "x-tombi-array-values-order": "version-sort"
        },
        "crate_type": {
          "type": "array",
          "items": {
            "type": "string",
            "x-taplo": {
              "hidden": true
            }
          },
          "uniqueItems": true,
          "x-taplo": {
            "hidden": true
          },
          "x-tombi-array-values-order": "version-sort"
        },
        "doc": {
          "type": "boolean",
          "description": "The `doc` field indicates whether or not the target is included in the\ndocumentation generated by [`cargo doc`](https://doc.rust-lang.org/cargo/commands/cargo-doc.html) by default. The default is `true` for\nlibraries and binaries.\n\n> **Note**: The binary will be skipped if its name is the same as the lib\n> target.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-doc-field"
            }
          }
        },
        "doctest": {
          "type": "boolean",
          "description": "The `doctest` field indicates whether or not [documentation examples](https://doc.rust-lang.org/rustdoc/documentation-tests.html) are\ntested by default by [`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html). This is only relevant for libraries, it\nhas no effect on other sections. The default is `true` for the library.\n",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-doctest-field"
            }
          }
        },
        "edition": {
          "$ref": "#/definitions/Edition"
        },
        "harness": {
          "type": "boolean",
          "description": "The `harness` field indicates that the [`--test` flag](https://doc.rust-lang.org/rustc/command-line-arguments.html#option-test) will be passed to\n`rustc` which will automatically include the libtest library which is the\ndriver for collecting and running tests marked with the [`#[test]` attribute](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) or benchmarks with the `#[bench]` attribute. The\ndefault is `true` for all targets.\n\nIf set to `false`, then you are responsible for defining a `main()` function\nto run tests and benchmarks.\n\nTests have the [`cfg(test)` conditional expression](https://doc.rust-lang.org/reference/conditional-compilation.html#test) enabled whether\nor not the harness is enabled.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-harness-field"
            }
          }
        },
        "path": {
          "type": "string",
          "description": "The `path` field specifies where the source for the crate is located, relative\nto the `Cargo.toml` file.\n\nIf not specified, the [inferred path](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery) is used based on\nthe target name.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-path-field"
            }
          }
        },
        "plugin": {
          "type": "boolean",
          "x-taplo": {
            "hidden": true
          }
        },
        "proc-macro": {
          "type": "boolean",
          "description": "The `proc-macro` field indicates that the library is a [procedural macro](https://doc.rust-lang.org/book/ch19-06-macros.html)\n([reference](https://doc.rust-lang.org/reference/procedural-macros.html)). This is only valid for the `[lib]`\ntarget.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-proc-macro-field"
            }
          }
        },
        "proc_macro": {
          "type": "boolean",
          "x-taplo": {
            "hidden": true
          }
        },
        "required-features": {
          "type": "array",
          "description": "The `required-features` field specifies which [features](https://doc.rust-lang.org/cargo/reference/features.html) the target needs in\norder to be built. If any of the required features are not enabled, the\ntarget will be skipped. This is only relevant for the `[[bin]]`, `[[bench]]`,\n`[[test]]`, and `[[example]]` sections, it has no effect on `[lib]`.\n\n```toml\n[features]\n# ...\npostgres = []\nsqlite = []\ntools = []\n\n[[bin]]\nname = \"my-pg-tool\"\nrequired-features = [\"postgres\", \"tools\"]\n```\n",
          "items": {
            "type": "string",
            "description": "The `required-features` field specifies which [features](https://doc.rust-lang.org/cargo/reference/features.html) the target needs in\norder to be built. If any of the required features are not enabled, the\ntarget will be skipped. This is only relevant for the `[[bin]]`, `[[bench]]`,\n`[[test]]`, and `[[example]]` sections, it has no effect on `[lib]`.\n\n```toml\n[features]\n# ...\npostgres = []\nsqlite = []\ntools = []\n\n[[bin]]\nname = \"my-pg-tool\"\nrequired-features = [\"postgres\", \"tools\"]\n```\n",
            "x-taplo": {
              "links": {
                "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-required-features-field"
              }
            }
          },
          "uniqueItems": true,
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-required-features-field"
            }
          },
          "x-tombi-array-values-order": "version-sort"
        },
        "test": {
          "type": "boolean",
          "description": "The `test` field indicates whether or not the target is tested by default by\n[`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html). The default is `true` for lib, bins, and tests.\n\n> **Note**: Examples are built by [`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html) by default to ensure they\n> continue to compile, but they are not *tested* by default. Setting `test =\n> true` for an example will also build it as a test and run any\n> [`#[test]`](https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute) functions defined in the example.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-test-field"
            }
          }
        }
      },
      "title": "Target",
      "x-tombi-table-keys-order": "schema"
    },
    "Workspace": {
      "type": "object",
      "description": "The `[workspace]` table in `Cargo.toml` defines which packages are members of\nthe workspace:\n\n```toml\n[workspace]\nmembers = [\"member1\", \"path/to/member2\", \"crates/*\"]\nexclude = [\"crates/foo\", \"path/to/other\"]\n```\n\nAn empty `[workspace]` table can be used with a `[package]` to conveniently\ncreate a workspace with the package and all of its path dependencies.\n\nAll [`path` dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-path-dependencies) residing in the workspace directory automatically\nbecome members. Additional members can be listed with the `members` key, which\nshould be an array of strings containing directories with `Cargo.toml` files.\n\nThe `members` list also supports [globs](https://docs.rs/glob/0.3.0/glob/struct.Pattern.html) to match multiple paths, using\ntypical filename glob patterns like `*` and `?`.\n\nThe `exclude` key can be used to prevent paths from being included in a\nworkspace. This can be useful if some path dependencies aren't desired to be\nin the workspace at all, or using a glob pattern and you want to remove a\ndirectory.\n\nAn empty `[workspace]` table can be used with a `[package]` to conveniently\ncreate a workspace with the package and all of its path dependencies.",
      "properties": {
        "default-members": {
          "type": "array",
          "description": "The optional `default-members` key can be specified to set the members to\noperate on when in the workspace root and the package selection flags are not\nused:\n\n```toml\n[workspace]\nmembers = [\"path/to/member1\", \"path/to/member2\", \"path/to/member3/*\"]\ndefault-members = [\"path/to/member2\", \"path/to/member3/foo\"]\n```\n\nWhen specified, `default-members` must expand to a subset of `members`.",
          "items": {
            "type": "string",
            "description": "The optional `default-members` key can be specified to set the members to\noperate on when in the workspace root and the package selection flags are not\nused:\n\n```toml\n[workspace]\nmembers = [\"path/to/member1\", \"path/to/member2\", \"path/to/member3/*\"]\ndefault-members = [\"path/to/member2\", \"path/to/member3/foo\"]\n```\n\nWhen specified, `default-members` must expand to a subset of `members`.",
            "x-taplo": {
              "links": {
                "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section"
              }
            }
          },
          "uniqueItems": true,
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section"
            }
          },
          "x-tombi-array-values-order": "version-sort"
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Dependency"
          },
          "description": "The `workspace.dependencies` table is where you define dependencies to be\ninherited by members of a workspace.\n\nSpecifying a workspace dependency is similar to [package dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) except:\n- Dependencies from this table cannot be declared as `optional`\n- [`features`][features] declared in this table are additive with the `features` from `[dependencies]`\n\nYou can then [inherit the workspace dependency as a package dependency](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace)\n\nExample:\n```toml\n# [PROJECT_DIR]/Cargo.toml\n[workspace]\nmembers = [\"bar\"]\n\n[workspace.dependencies]\ncc = \"1.0.73\"\nrand = \"0.8.5\"\nregex = { version = \"1.6.0\", default-features = false, features = [\"std\"] }\n```\n\n```toml\n# [PROJECT_DIR]/bar/Cargo.toml\n[package]\nname = \"bar\"\nversion = \"0.2.0\"\n\n[dependencies]\nregex = { workspace = true, features = [\"unicode\"] }\n\n[build-dependencies]\ncc.workspace = true\n\n[dev-dependencies]\nrand.workspace = true\n```",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section"
            }
          },
          "x-tombi-table-keys-order": "version-sort"
        },
        "exclude": {
          "type": "array",
          "description": "The `exclude` key can be used to prevent paths from being included in a\nworkspace. This can be useful if some path dependencies aren't desired to be\nin the workspace at all, or using a glob pattern and you want to remove a\ndirectory.",
          "items": {
            "type": "string",
            "description": "The `exclude` key can be used to prevent paths from being included in a\nworkspace. This can be useful if some path dependencies aren't desired to be\nin the workspace at all, or using a glob pattern and you want to remove a\ndirectory.",
            "x-taplo": {
              "links": {
                "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section"
              }
            }
          },
          "uniqueItems": true,
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section"
            }
          },
          "x-tombi-array-values-order": "version-sort"
        },
        "lints": {
          "$ref": "#/definitions/Lints",
          "description": "The `workspace.lints` table is where you define lint configuration to be inherited by members of a workspace.",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section"
            }
          }
        },
        "members": {
          "type": "array",
          "description": "All [`path` dependencies] residing in the workspace directory automatically\nbecome members. Additional members can be listed with the `members` key, which\nshould be an array of strings containing directories with `Cargo.toml` files.\n\nThe `members` list also supports [globs] to match multiple paths, using\ntypical filename glob patterns like `*` and `?`.",
          "items": {
            "type": "string",
            "description": "All [`path` dependencies] residing in the workspace directory automatically\nbecome members. Additional members can be listed with the `members` key, which\nshould be an array of strings containing directories with `Cargo.toml` files.\n\nThe `members` list also supports [globs] to match multiple paths, using\ntypical filename glob patterns like `*` and `?`.",
            "x-taplo": {
              "links": {
                "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section"
              }
            }
          },
          "uniqueItems": true,
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section"
            }
          },
          "x-tombi-array-values-order": "version-sort"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "description": "The `workspace.metadata` table is ignored by Cargo and will not be warned\nabout. This section can be used for tools that would like to store workspace\nconfiguration in `Cargo.toml`. For example:\n\n```toml\n[workspace]\nmembers = [\"member1\", \"member2\"]\n\n[workspace.metadata.webcontents]\nroot = \"path/to/webproject\"\ntool = [\"npm\", \"run\", \"build\"]\n# ...\n```\n\nThere is a similar set of tables at the package level at\n`package.metadata`. While cargo does not specify a\nformat for the content of either of these tables, it is suggested that\nexternal tools may wish to use them in a consistent fashion, such as referring\nto the data in `workspace.metadata` if data is missing from `package.metadata`,\nif that makes sense for the tool in question.\n",
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html#the-workspace-section"
            }
          }
        },
        "package": {
          "type": "object",
          "description": "The `workspace.package` table is where you define keys that can be\ninherited by members of a workspace. These keys can be inherited by\ndefining them in the member package with `{key}.workspace = true`.\n\nKeys that are supported:\n\n|                |                 |\n|----------------|-----------------|\n| `authors`      | `categories`    |\n| `description`  | `documentation` |\n| `edition`      | `exclude`       |\n| `homepage`     | `include`       |\n| `keywords`     | `license`       |\n| `license-file` | `publish`       |\n| `readme`       | `repository`    |\n| `rust-version` | `version`       |\n\n- `license-file` and `readme` are relative to the workspace root\n- `include` and `exclude` are relative to your package root\n\nExample:\n```toml\n# [PROJECT_DIR]/Cargo.toml\n[workspace]\nmembers = [\"bar\"]\n\n[workspace.package]\nversion = \"1.2.3\"\nauthors = [\"Nice Folks\"]\ndescription = \"A short description of my package\"\ndocumentation = \"https://example.com/bar\"\n```\n\n```toml\n# [PROJECT_DIR]/bar/Cargo.toml\n[package]\nname = \"bar\"\nversion.workspace = true\nauthors.workspace = true\ndescription.workspace = true\ndocumentation.workspace = true\n```",
          "properties": {
            "authors": {
              "$ref": "#/definitions/Authors"
            },
            "categories": {
              "$ref": "#/definitions/Categories"
            },
            "description": {
              "$ref": "#/definitions/Description"
            },
            "documentation": {
              "$ref": "#/definitions/Documentation"
            },
            "edition": {
              "$ref": "#/definitions/Edition"
            },
            "exclude": {
              "$ref": "#/definitions/Exclude"
            },
            "homepage": {
              "$ref": "#/definitions/Homepage"
            },
            "include": {
              "$ref": "#/definitions/Include"
            },
            "keywords": {
              "$ref": "#/definitions/Keywords"
            },
            "license": {
              "$ref": "#/definitions/License"
            },
            "license-file": {
              "$ref": "#/definitions/LicenseFile"
            },
            "publish": {
              "$ref": "#/definitions/Publish"
            },
            "readme": {
              "$ref": "#/definitions/Readme"
            },
            "repository": {
              "$ref": "#/definitions/Repository"
            },
            "rust-version": {
              "$ref": "#/definitions/RustVersion"
            },
            "version": {
              "$ref": "#/definitions/SemVer"
            }
          },
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table"
            }
          },
          "x-tombi-table-keys-order": "schema"
        },
        "resolver": {
          "$ref": "#/definitions/Resolver"
        }
      },
      "title": "Workspace",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/workspaces.html"
        }
      },
      "x-tombi-table-keys-order": "schema"
    },
    "WorkspaceInheritance": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "workspace": {
          "type": "boolean",
          "description": "The `workspace` field allow keys to be inherited by defining them in the member package with `{key}.workspace = true`",
          "enum": [
            true
          ],
          "title": "Workspace"
        }
      },
      "required": [
        "workspace"
      ],
      "x-tombi-table-keys-order": "schema"
    }
  },
  "description": "A schema for Cargo.toml.",
  "properties": {
    "badges": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": {
          "type": "string"
        },
        "x-tombi-table-keys-order": "version-sort"
      },
      "description": "[crates.io](https://crates.io) can display various badges for build status, test coverage, etc. for\neach crate. All badges are optional.\n\n- The badges pertaining to build status that are currently available are\n  Appveyor, CircleCI, Cirrus CI, GitLab, Azure DevOps, Travis CI and Bitbucket\n  Pipelines.\n- Available badges pertaining to code test coverage are Codecov and Coveralls.\n- There are also maintenance-related badges based on isitmaintained.com\n  which state the issue resolution time, percent of open issues, and future\n  maintenance intentions.\n\nMost badge specifications require a `repository` key. It is expected to be in\n`user/repo` format.\n\n```toml\n[badges]\n\n# Appveyor: `repository` is required. `branch` is optional; default is `master`\n# `service` is optional; valid values are `github` (default), `bitbucket`, and\n# `gitlab`; `id` is optional; you can specify the appveyor project id if you\n# want to use that instead. `project_name` is optional; use when the repository\n# name differs from the appveyor project name.\nappveyor = { repository = \"...\", branch = \"master\", service = \"github\" }\n\n# Circle CI: `repository` is required. `branch` is optional; default is `master`\ncircle-ci = { repository = \"...\", branch = \"master\" }\n\n# Cirrus CI: `repository` is required. `branch` is optional; default is `master`\ncirrus-ci = { repository = \"...\", branch = \"master\" }\n\n# GitLab: `repository` is required. `branch` is optional; default is `master`\ngitlab = { repository = \"...\", branch = \"master\" }\n\n# Azure DevOps: `project` is required. `pipeline` is required. `build` is optional; default is `1`\n# Note: project = `organization/project`, pipeline = `name_of_pipeline`, build = `definitionId`\nazure-devops = { project = \"...\", pipeline = \"...\", build=\"2\" }\n\n# Travis CI: `repository` in format \"<user>/<project>\" is required.\n# `branch` is optional; default is `master`\ntravis-ci = { repository = \"...\", branch = \"master\" }\n\n# Bitbucket Pipelines: `repository` is required. `branch` is required\nbitbucket-pipelines = { repository = \"...\", branch = \"master\" }\n\n# Codecov: `repository` is required. `branch` is optional; default is `master`\n# `service` is optional; valid values are `github` (default), `bitbucket`, and\n# `gitlab`.\ncodecov = { repository = \"...\", branch = \"master\", service = \"github\" }\n\n# Coveralls: `repository` is required. `branch` is optional; default is `master`\n# `service` is optional; valid values are `github` (default) and `bitbucket`.\ncoveralls = { repository = \"...\", branch = \"master\", service = \"github\" }\n\n# Is it maintained resolution time: `repository` is required.\nis-it-maintained-issue-resolution = { repository = \"...\" }\n\n# Is it maintained percentage of open issues: `repository` is required.\nis-it-maintained-open-issues = { repository = \"...\" }\n\n# Maintenance: `status` is required. Available options are:\n# - `actively-developed`: New features are being added and bugs are being fixed.\n# - `passively-maintained`: There are no plans for new features, but the maintainer intends to\n#   respond to issues that get filed.\n# - `as-is`: The crate is feature complete, the maintainer does not intend to continue working on\n#   it or providing support, but it works for the purposes it was designed for.\n# - `experimental`: The author wants to share it with the community but is not intending to meet\n#   anyone's particular use case.\n# - `looking-for-maintainer`: The current maintainer would like to transfer the crate to someone\n#   else.\n# - `deprecated`: The maintainer does not recommend using this crate (the description of the crate\n#   can describe why, there could be a better solution available or there could be problems with\n#   the crate that the author does not want to fix).\n# - `none`: Displays no badge on crates.io, since the maintainer has not chosen to specify\n#   their intentions, potential crate users will need to investigate on their own.\nmaintenance = { status = \"...\" }\n```",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/manifest.html#the-badges-section"
        }
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "bench": {
      "type": "array",
      "description": "Benchmarks provide a way to test the performance of your code using the\n[`cargo bench`](https://doc.rust-lang.org/cargo/commands/cargo-bench.html) command. They follow the same structure as [tests](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#tests),\nwith each benchmark function annotated with the `#[bench]` attribute.\nSimilarly to tests:\n\n* Benchmarks are placed in the [`benches` directory](https://doc.rust-lang.org/cargo/guide/project-layout.html).\n* Benchmark functions defined in libraries and binaries have access to the\n  *private* API within the target they are defined in. Benchmarks in the\n  `benches` directory may use the *public* API.\n* [The `bench` field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-bench-field) can be used to define which targets\n  are benchmarked by default.\n* [The `harness` field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-harness-field) can be used to disable the\n  built-in harness.\n\n> **Note**: The [`#[bench]`\n> attribute](https://doc.rust-lang.org/unstable-book/library-features/test.html) is currently\n> unstable and only available on the [nightly channel](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html). There are some\n> packages available on [crates.io](https://crates.io/keywords/benchmark) that\n> may help with running benchmarks on the stable channel, such as\n> [Criterion](https://crates.io/crates/criterion).",
      "items": {
        "$ref": "#/definitions/Target",
        "description": "Benchmarks provide a way to test the performance of your code using the\n[`cargo bench`](https://doc.rust-lang.org/cargo/commands/cargo-bench.html) command. They follow the same structure as [tests](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#tests),\nwith each benchmark function annotated with the `#[bench]` attribute.\nSimilarly to tests:\n\n* Benchmarks are placed in the [`benches` directory](https://doc.rust-lang.org/cargo/guide/project-layout.html).\n* Benchmark functions defined in libraries and binaries have access to the\n  *private* API within the target they are defined in. Benchmarks in the\n  `benches` directory may use the *public* API.\n* [The `bench` field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-bench-field) can be used to define which targets\n  are benchmarked by default.\n* [The `harness` field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-harness-field) can be used to disable the\n  built-in harness.\n\n> **Note**: The [`#[bench]`\n> attribute](https://doc.rust-lang.org/unstable-book/library-features/test.html) is currently\n> unstable and only available on the [nightly channel](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html). There are some\n> packages available on [crates.io](https://crates.io/keywords/benchmark) that\n> may help with running benchmarks on the stable channel, such as\n> [Criterion](https://crates.io/crates/criterion).",
        "x-taplo": {
          "links": {
            "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#benchmarks"
          }
        }
      },
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#benchmarks"
        }
      },
      "x-tombi-array-values-order": "version-sort"
    },
    "bin": {
      "type": "array",
      "description": "Binary targets are executable programs that can be run after being compiled.\nThe default binary filename is `src/main.rs`, which defaults to the name of\nthe package. Additional binaries are stored in the [`src/bin/`\ndirectory](https://doc.rust-lang.org/cargo/guide/project-layout.html). The settings for each binary can be [customized](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#configuring-a-target) in the `[[bin]]` tables in `Cargo.toml`.\n\nBinaries can use the public API of the package's library. They are also linked\nwith the [`[dependencies]`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) defined in `Cargo.toml`.\n\nYou can run individual binaries with the [`cargo run`](https://doc.rust-lang.org/cargo/commands/cargo-run.html) command with the `--bin\n<bin-name>` option. [`cargo install`](https://doc.rust-lang.org/cargo/commands/cargo-install.html) can be used to copy the executable to a\ncommon location.\n\n```toml\n# Example of customizing binaries in Cargo.toml.\n[[bin]]\nname = \"cool-tool\"\ntest = false\nbench = false\n\n[[bin]]\nname = \"frobnicator\"\nrequired-features = [\"frobnicate\"]\n```",
      "items": {
        "$ref": "#/definitions/Target",
        "description": "Binary targets are executable programs that can be run after being compiled.\nThe default binary filename is `src/main.rs`, which defaults to the name of\nthe package. Additional binaries are stored in the [`src/bin/`\ndirectory](https://doc.rust-lang.org/cargo/guide/project-layout.html). The settings for each binary can be [customized](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#configuring-a-target) in the `[[bin]]` tables in `Cargo.toml`.\n\nBinaries can use the public API of the package's library. They are also linked\nwith the [`[dependencies]`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) defined in `Cargo.toml`.\n\nYou can run individual binaries with the [`cargo run`](https://doc.rust-lang.org/cargo/commands/cargo-run.html) command with the `--bin\n<bin-name>` option. [`cargo install`](https://doc.rust-lang.org/cargo/commands/cargo-install.html) can be used to copy the executable to a\ncommon location.\n\n```toml\n# Example of customizing binaries in Cargo.toml.\n[[bin]]\nname = \"cool-tool\"\ntest = false\nbench = false\n\n[[bin]]\nname = \"frobnicator\"\nrequired-features = [\"frobnicate\"]\n```",
        "x-taplo": {
          "links": {
            "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries"
          }
        }
      },
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries"
        }
      },
      "x-tombi-array-values-order": "version-sort"
    },
    "build-dependencies": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Dependency"
      },
      "description": "You can depend on other Cargo-based crates for use in your build scripts.\nDependencies are declared through the `build-dependencies` section of the\nmanifest:\n\n```toml\n[build-dependencies]\ncc = \"1.0.3\"\n```\n\nThe build script **does not** have access to the dependencies listed\nin the `dependencies` or `dev-dependencies` section. Build\ndependencies will likewise not be available to the package itself\nunless listed under the `dependencies` section as well. A package\nitself and its build script are built separately, so their\ndependencies need not coincide. Cargo is kept simpler and cleaner by\nusing independent dependencies for independent purposes.",
      "x-taplo": {
        "crates": {
          "schemas": "dependencies"
        },
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#build-dependencies"
        },
        "plugins": [
          "crates"
        ]
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "build_dependencies": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Dependency"
      },
      "deprecated": true,
      "description": "[build_dependencies] is deprecated. Use [build-dependencies] instead.",
      "x-taplo": {
        "hidden": true
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "cargo-features": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "uniqueItems": true,
      "x-tombi-array-values-order": "version-sort"
    },
    "dependencies": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Dependency"
      },
      "description": "Cargo is configured to look for dependencies on [crates.io](https://crates.io) by default. Only\nthe name and a version string are required in this case. In [the cargo\nguide](https://doc.rust-lang.org/cargo/guide/index.html), we specified a dependency on the `time` crate:\n\n```toml\n[dependencies]\ntime = \"0.1.12\"\n```\n\nThe string `\"0.1.12\"` is a [semver](https://github.com/steveklabnik/semver#requirements) version requirement. Since this\nstring does not have any operators in it, it is interpreted the same way as\nif we had specified `\"^0.1.12\"`, which is called a caret requirement.\n\nA dependency can also be defined by a table with additional options:\n\n```toml\n[dependencies]\ntime = { path = \"../time\", version = \"0.1.12\" }\n```",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html"
        }
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "dev-dependencies": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Dependency"
      },
      "description": "The format of `[dev-dependencies]` is equivalent to `[dependencies]`:\n\n```toml\n[dev-dependencies]\ntempdir = \"0.3\"\n```\n\nDev-dependencies are not used when compiling\na package for building, but are used for compiling tests, examples, and\nbenchmarks.\n\nThese dependencies are *not* propagated to other packages which depend on this\npackage.\n\nYou can also have target-specific development dependencies by using\n`dev-dependencies` in the target section header instead of `dependencies`. For\nexample:\n\n```toml\n[target.'cfg(unix)'.dev-dependencies]\nmio = \"0.0.1\"\n```\n\n> **Note**: When a package is published, only dev-dependencies that specify a\n> `version` will be included in the published crate. For most use cases,\n> dev-dependencies are not needed when published, though some users (like OS\n> packagers) may want to run tests within a crate, so providing a `version` if\n> possible can still be beneficial.\n",
      "x-taplo": {
        "crates": {
          "schemas": "dependencies"
        },
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies"
        },
        "plugins": [
          "crates"
        ]
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "dev_dependencies": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Dependency"
      },
      "deprecated": true,
      "description": "[dev_dependencies] is deprecated. Use [dev-dependencies] instead.",
      "x-taplo": {
        "hidden": true
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "example": {
      "type": "array",
      "description": "Files located under the [examples directory](https://doc.rust-lang.org/cargo/guide/project-layout.html) are example uses of the functionality provided by the library. When compiled, they are placed in the[ target/debug/examples directory](https://doc.rust-lang.org/cargo/guide/build-cache.html).\n\nExamples can use the public API of the package's library. They are also linked with the [dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) and [dev-dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies) defined in Cargo.toml.\n\nBy default, examples are executable binaries (with a `main()` function). You\ncan specify the [`crate-type` field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-crate-type-field) to make an example\nbe compiled as a library:\n\n```toml\n[[example]]\nname = \"foo\"\ncrate-type = [\"staticlib\"]\n```\n\nYou can run individual executable examples with the [`cargo run`](https://doc.rust-lang.org/cargo/commands/cargo-run.html) command with\nthe `--example <example-name>` option. Library examples can be built with\n[`cargo build`](https://doc.rust-lang.org/cargo/commands/cargo-build.html) with the `--example <example-name>` option. [`cargo install`](https://doc.rust-lang.org/cargo/commands/cargo-install.html)\nwith the `--example <example-name>` option can be used to copy executable\nbinaries to a common location. Examples are compiled by [`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html) by\ndefault to protect them from bit-rotting. Set [the `test`\nfield](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-test-field) to `true` if you have `#[test]` functions in the\nexample that you want to run with [`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html).\n",
      "items": {
        "$ref": "#/definitions/Target",
        "description": "Files located under the [examples directory](https://doc.rust-lang.org/cargo/guide/project-layout.html) are example uses of the functionality provided by the library. When compiled, they are placed in the[ target/debug/examples directory](https://doc.rust-lang.org/cargo/guide/build-cache.html).\n\nExamples can use the public API of the package's library. They are also linked with the [dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) and [dev-dependencies](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies) defined in Cargo.toml.\n\nBy default, examples are executable binaries (with a `main()` function). You\ncan specify the [`crate-type` field](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-crate-type-field) to make an example\nbe compiled as a library:\n\n```toml\n[[example]]\nname = \"foo\"\ncrate-type = [\"staticlib\"]\n```\n\nYou can run individual executable examples with the [`cargo run`](https://doc.rust-lang.org/cargo/commands/cargo-run.html) command with\nthe `--example <example-name>` option. Library examples can be built with\n[`cargo build`](https://doc.rust-lang.org/cargo/commands/cargo-build.html) with the `--example <example-name>` option. [`cargo install`](https://doc.rust-lang.org/cargo/commands/cargo-install.html)\nwith the `--example <example-name>` option can be used to copy executable\nbinaries to a common location. Examples are compiled by [`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html) by\ndefault to protect them from bit-rotting. Set [the `test`\nfield](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-test-field) to `true` if you have `#[test]` functions in the\nexample that you want to run with [`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html).\n",
        "x-taplo": {
          "links": {
            "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#examples"
          }
        }
      },
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#examples"
        }
      },
      "x-tombi-array-values-order": "version-sort"
    },
    "features": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "uniqueItems": true,
        "x-tombi-array-values-order": "version-sort"
      },
      "description": "Cargo supports features to allow expression of:\n\n* conditional compilation options (usable through `cfg` attributes);\n* optional dependencies, which enhance a package, but are not required; and\n* clusters of optional dependencies, such as `postgres-all`, that would include the\n  `postgres` package, the `postgres-macros` package, and possibly other packages\n  (such as development-time mocking libraries, debugging tools, etc.).\n\nA feature of a package is either an optional dependency, or a set of other\nfeatures.\n",
      "properties": {
        "default": {
          "type": "array",
          "description": "The default features of the crate.",
          "items": {
            "type": "string"
          },
          "title": "Default Feature",
          "uniqueItems": true,
          "x-taplo": {
            "links": {
              "key": "https://doc.rust-lang.org/cargo/reference/features.html#the-default-feature"
            }
          },
          "x-tombi-array-values-order": "version-sort"
        }
      },
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/features.html"
        }
      },
      "x-tombi-table-keys-order": {
        "additionalProperties": "version-sort",
        "properties": "schema"
      }
    },
    "lib": {
      "$ref": "#/definitions/Target",
      "x-taplo": {
        "docs": {
          "main": "The library target defines a \"library\" that can be used and linked by other\nlibraries and executables. The filename defaults to `src/lib.rs`, and the name\nof the library defaults to the name of the package. A package can have only\none library. The settings for the library can be [customized](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#configuring-a-target) in the `[lib]`\ntable in `Cargo.toml`.\n\n```toml\n# Example of customizing the library in Cargo.toml.\n[lib]\ncrate-type = [\"cdylib\"]\nbench = false\n```\n"
        },
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#library"
        }
      }
    },
    "lints": {
      "anyOf": [
        {
          "$ref": "#/definitions/Lints"
        },
        {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "workspace": {
              "type": "boolean",
              "description": "Inherit lints from the workspace manifest."
            }
          },
          "required": [
            "workspace"
          ],
          "x-tombi-table-keys-order": "version-sort"
        }
      ],
      "description": "Override the default level of lints from different tools by assigning them to a new level in a table.",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/stable/cargo/reference/manifest.html#the-lints-section"
        }
      }
    },
    "package": {
      "$ref": "#/definitions/Package"
    },
    "patch": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/definitions/Dependency"
        },
        "x-tombi-table-keys-order": "version-sort"
      },
      "description": "The `[patch]` section of `Cargo.toml` can be used to override dependencies\nwith other copies. The syntax is similar to the\n[`[dependencies]`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) section.\n\n",
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html#the-patch-section"
        }
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "profile": {
      "$ref": "#/definitions/Profiles"
    },
    "project": {
      "$ref": "#/definitions/Package",
      "deprecated": true,
      "description": "[project] is deprecated. Use [package] instead.",
      "x-taplo": {
        "hidden": true
      }
    },
    "replace": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Dependency"
      },
      "x-taplo": {
        "hidden": true
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "target": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Platform"
      },
      "x-tombi-table-keys-order": "version-sort"
    },
    "test": {
      "type": "array",
      "description": "Files located under the [`tests` directory](https://doc.rust-lang.org/cargo/guide/project-layout.html) are integration\ntests. When you run [`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html), Cargo will compile each of these files as\na separate crate, and execute them.\n\nIntegration tests can use the public API of the package's library. They are\nalso linked with the [`[dependencies]`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) and\n[`[dev-dependencies]`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies) defined in `Cargo.toml`.\n\nIf you want to share code among multiple integration tests, you can place it\nin a separate module such as `tests/common/mod.rs` and then put `mod common;`\nin each test to import it.\n\nEach integration test results in a separate executable binary, and [`cargo\ntest`](https://doc.rust-lang.org/cargo/commands/cargo-test.html) will run them serially. In some cases this can be inefficient, as it\ncan take longer to compile, and may not make full use of multiple CPUs when\nrunning the tests. If you have a lot of integration tests, you may want to\nconsider creating a single integration test, and split the tests into multiple\nmodules. The libtest harness will automatically find all of the `#[test]`\nannotated functions and run them in parallel. You can pass module names to\n[`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html) to only run the tests within that module.\n\nBinary targets are automatically built if there is an integration test. This\nallows an integration test to execute the binary to exercise and test its\nbehavior. The `CARGO_BIN_EXE_<name>` [environment variable](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates) is set when the\nintegration test is built so that it can use the [`env` macro](https://doc.rust-lang.org/std/macro.env.html) to locate the\nexecutable.",
      "items": {
        "$ref": "#/definitions/Target",
        "description": "Files located under the [`tests` directory](https://doc.rust-lang.org/cargo/guide/project-layout.html) are integration\ntests. When you run [`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html), Cargo will compile each of these files as\na separate crate, and execute them.\n\nIntegration tests can use the public API of the package's library. They are\nalso linked with the [`[dependencies]`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) and\n[`[dev-dependencies]`](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies) defined in `Cargo.toml`.\n\nIf you want to share code among multiple integration tests, you can place it\nin a separate module such as `tests/common/mod.rs` and then put `mod common;`\nin each test to import it.\n\nEach integration test results in a separate executable binary, and [`cargo\ntest`](https://doc.rust-lang.org/cargo/commands/cargo-test.html) will run them serially. In some cases this can be inefficient, as it\ncan take longer to compile, and may not make full use of multiple CPUs when\nrunning the tests. If you have a lot of integration tests, you may want to\nconsider creating a single integration test, and split the tests into multiple\nmodules. The libtest harness will automatically find all of the `#[test]`\nannotated functions and run them in parallel. You can pass module names to\n[`cargo test`](https://doc.rust-lang.org/cargo/commands/cargo-test.html) to only run the tests within that module.\n\nBinary targets are automatically built if there is an integration test. This\nallows an integration test to execute the binary to exercise and test its\nbehavior. The `CARGO_BIN_EXE_<name>` [environment variable](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates) is set when the\nintegration test is built so that it can use the [`env` macro](https://doc.rust-lang.org/std/macro.env.html) to locate the\nexecutable.",
        "x-taplo": {
          "links": {
            "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#integration-tests"
          }
        }
      },
      "x-taplo": {
        "links": {
          "key": "https://doc.rust-lang.org/cargo/reference/cargo-targets.html#integration-tests"
        }
      },
      "x-tombi-array-values-order": "version-sort"
    },
    "workspace": {
      "$ref": "#/definitions/Workspace"
    }
  },
  "title": "Cargo.toml",
  "x-taplo-info": {
    "authors": [
      "tamasfe (https://github.com/tamasfe)"
    ],
    "patterns": [
      "^(.*(/|\\\\)Cargo\\.toml|Cargo\\.toml)$"
    ]
  },
  "x-tombi-table-keys-order": "schema",
  "x-tombi-toml-version": "v1.0.0"
}
